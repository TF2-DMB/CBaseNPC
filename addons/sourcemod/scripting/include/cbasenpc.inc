#if !defined _CBASENPC_EXTENSION_INC_
#define _CBASENPC_EXTENSION_INC_

#define EFL_DIRTY_SURROUNDING_COLLISION_BOUNDS	(1<<14)

#define EF_BONEMERGE			0x001 	// Performs bone merge on client side
#define	EF_BRIGHTLIGHT 			0x002	// DLIGHT centered at entity origin
#define	EF_DIMLIGHT 			0x004	// player flashlight
#define	EF_NOINTERP				0x008	// don't interpolate the next frame
#define	EF_NOSHADOW				0x010	// Don't cast no shadow
#define	EF_NODRAW				0x020	// don't draw entity
#define	EF_NORECEIVESHADOW		0x040	// Don't receive no shadow
#define	EF_BONEMERGE_FASTCULL	0x080	// For use with EF_BONEMERGE. If this is set, then it places this ent's origin at its
										// parent and uses the parent's bbox + the max extents of the aiment.
										// Otherwise, it sets up the parent's bones every frame to figure out where to place
										// the aiment, which is inefficient because it'll setup the parent's bones even if
										// the parent is not in the PVS.
#define	EF_ITEM_BLINK			0x100	// blink an item so that the user notices it.
#define	EF_PARENT_ANIMATES		0x200	// always assume that the parent entity is animating
#define	EF_MAX_BITS = 10

enum Activity
{
	ACT_INVALID = -1,			// So we have something more succint to check for than '-1'
	ACT_RESET = 0,				// Set m_Activity to this invalid value to force a reset to m_IdealActivity
	ACT_IDLE,
	ACT_TRANSITION,
	ACT_COVER,					// FIXME: obsolete? redundant with ACT_COVER_LOW?
	ACT_COVER_MED,				// FIXME: unsupported?
	ACT_COVER_LOW,				// FIXME: rename ACT_IDLE_CROUCH?
	ACT_WALK,
	ACT_WALK_AIM,
	ACT_WALK_CROUCH,
	ACT_WALK_CROUCH_AIM,
	ACT_RUN,
	ACT_RUN_AIM,
	ACT_RUN_CROUCH,
	ACT_RUN_CROUCH_AIM,
	ACT_RUN_PROTECTED,
	ACT_SCRIPT_CUSTOM_MOVE,
	ACT_RANGE_ATTACK1,
	ACT_RANGE_ATTACK2,
	ACT_RANGE_ATTACK1_LOW,		// FIXME: not used yet, crouched versions of the range attack
	ACT_RANGE_ATTACK2_LOW,		// FIXME: not used yet, crouched versions of the range attack
	ACT_DIESIMPLE,
	ACT_DIEBACKWARD,
	ACT_DIEFORWARD,
	ACT_DIEVIOLENT,
	ACT_DIERAGDOLL,
	ACT_FLY,				// Fly (and flap if appropriate)
	ACT_HOVER,
	ACT_GLIDE,
	ACT_SWIM,
	ACT_JUMP,
	ACT_HOP,				// vertical jump
	ACT_LEAP,				// long forward jump
	ACT_LAND,
	ACT_CLIMB_UP,
	ACT_CLIMB_DOWN,
	ACT_CLIMB_DISMOUNT,
	ACT_SHIPLADDER_UP,
	ACT_SHIPLADDER_DOWN,
	ACT_STRAFE_LEFT,
	ACT_STRAFE_RIGHT,
	ACT_ROLL_LEFT,			// tuck and roll, left
	ACT_ROLL_RIGHT,			// tuck and roll, right
	ACT_TURN_LEFT,			// turn quickly left (stationary)
	ACT_TURN_RIGHT,			// turn quickly right (stationary)
	ACT_CROUCH,				// FIXME: obsolete? only used be soldier (the act of crouching down from a standing position)
	ACT_CROUCHIDLE,			// FIXME: obsolete? only used be soldier (holding body in crouched position (loops))
	ACT_STAND,				// FIXME: obsolete? should be transition (the act of standing from a crouched position)
	ACT_USE,
	ACT_SIGNAL1,
	ACT_SIGNAL2,
	ACT_SIGNAL3,

	ACT_SIGNAL_ADVANCE,		// Squad handsignals, specific.
	ACT_SIGNAL_FORWARD,
	ACT_SIGNAL_GROUP,
	ACT_SIGNAL_HALT,
	ACT_SIGNAL_LEFT,
	ACT_SIGNAL_RIGHT,
	ACT_SIGNAL_TAKECOVER,

	ACT_LOOKBACK_RIGHT,		// look back over shoulder without turning around.
	ACT_LOOKBACK_LEFT,
	ACT_COWER,				// FIXME: unused, should be more extreme version of crouching
	ACT_SMALL_FLINCH,		// FIXME: needed? shouldn't flinching be down with overlays?
	ACT_BIG_FLINCH,		
	ACT_MELEE_ATTACK1,
	ACT_MELEE_ATTACK2,
	ACT_RELOAD,
	ACT_RELOAD_START,
	ACT_RELOAD_FINISH,
	ACT_RELOAD_LOW,
	ACT_ARM,				// pull out gun, for instance
	ACT_DISARM,				// reholster gun
	ACT_DROP_WEAPON,
	ACT_DROP_WEAPON_SHOTGUN,
	ACT_PICKUP_GROUND,		// pick up something in front of you on the ground
	ACT_PICKUP_RACK,		// pick up something from a rack or shelf in front of you.
	ACT_IDLE_ANGRY,			// FIXME: being used as an combat ready idle?  alternate idle animation in which the monster is clearly agitated. (loop)

	ACT_IDLE_RELAXED,
	ACT_IDLE_STIMULATED,
	ACT_IDLE_AGITATED,
	ACT_IDLE_STEALTH,
	ACT_IDLE_HURT,

	ACT_WALK_RELAXED,
	ACT_WALK_STIMULATED,
	ACT_WALK_AGITATED,
	ACT_WALK_STEALTH,

	ACT_RUN_RELAXED,
	ACT_RUN_STIMULATED,
	ACT_RUN_AGITATED,
	ACT_RUN_STEALTH,
		
	ACT_IDLE_AIM_RELAXED,
	ACT_IDLE_AIM_STIMULATED,
	ACT_IDLE_AIM_AGITATED,
	ACT_IDLE_AIM_STEALTH,

	ACT_WALK_AIM_RELAXED,
	ACT_WALK_AIM_STIMULATED,
	ACT_WALK_AIM_AGITATED,
	ACT_WALK_AIM_STEALTH,

	ACT_RUN_AIM_RELAXED,
	ACT_RUN_AIM_STIMULATED,
	ACT_RUN_AIM_AGITATED,
	ACT_RUN_AIM_STEALTH,

	ACT_CROUCHIDLE_STIMULATED,
	ACT_CROUCHIDLE_AIM_STIMULATED,
	ACT_CROUCHIDLE_AGITATED,

	ACT_WALK_HURT,			// limp  (loop)
	ACT_RUN_HURT,			// limp  (loop)
	ACT_SPECIAL_ATTACK1,	// very monster specific special attacks.
	ACT_SPECIAL_ATTACK2,	
	ACT_COMBAT_IDLE,		// FIXME: unused?  agitated idle.
	ACT_WALK_SCARED,
	ACT_RUN_SCARED,
	ACT_VICTORY_DANCE,		// killed a player, do a victory dance.
	ACT_DIE_HEADSHOT,		// die, hit in head. 
	ACT_DIE_CHESTSHOT,		// die, hit in chest
	ACT_DIE_GUTSHOT,		// die, hit in gut
	ACT_DIE_BACKSHOT,		// die, hit in back
	ACT_FLINCH_HEAD,
	ACT_FLINCH_CHEST,
	ACT_FLINCH_STOMACH,
	ACT_FLINCH_LEFTARM,
	ACT_FLINCH_RIGHTARM,
	ACT_FLINCH_LEFTLEG,
	ACT_FLINCH_RIGHTLEG,
	ACT_FLINCH_PHYSICS,

	ACT_IDLE_ON_FIRE,		// ON FIRE animations
	ACT_WALK_ON_FIRE,
	ACT_RUN_ON_FIRE,		

	ACT_RAPPEL_LOOP,		// Rappel down a rope!

	ACT_180_LEFT,			// 180 degree left turn
	ACT_180_RIGHT,

	ACT_90_LEFT,			// 90 degree turns
	ACT_90_RIGHT,

	ACT_STEP_LEFT,			// Single steps
	ACT_STEP_RIGHT,
	ACT_STEP_BACK,
	ACT_STEP_FORE,

	ACT_GESTURE_RANGE_ATTACK1,
	ACT_GESTURE_RANGE_ATTACK2,
	ACT_GESTURE_MELEE_ATTACK1,
	ACT_GESTURE_MELEE_ATTACK2,
	ACT_GESTURE_RANGE_ATTACK1_LOW,	// FIXME: not used yet, crouched versions of the range attack
	ACT_GESTURE_RANGE_ATTACK2_LOW,	// FIXME: not used yet, crouched versions of the range attack

	ACT_MELEE_ATTACK_SWING_GESTURE,

	ACT_GESTURE_SMALL_FLINCH,
	ACT_GESTURE_BIG_FLINCH,
	ACT_GESTURE_FLINCH_BLAST,			// Startled by an explosion
	ACT_GESTURE_FLINCH_BLAST_SHOTGUN,
	ACT_GESTURE_FLINCH_BLAST_DAMAGED,	// Damaged by an explosion
	ACT_GESTURE_FLINCH_BLAST_DAMAGED_SHOTGUN,
	ACT_GESTURE_FLINCH_HEAD,
	ACT_GESTURE_FLINCH_CHEST,
	ACT_GESTURE_FLINCH_STOMACH,
	ACT_GESTURE_FLINCH_LEFTARM,
	ACT_GESTURE_FLINCH_RIGHTARM,
	ACT_GESTURE_FLINCH_LEFTLEG,
	ACT_GESTURE_FLINCH_RIGHTLEG,

	ACT_GESTURE_TURN_LEFT,
	ACT_GESTURE_TURN_RIGHT,
	ACT_GESTURE_TURN_LEFT45,
	ACT_GESTURE_TURN_RIGHT45,
	ACT_GESTURE_TURN_LEFT90,
	ACT_GESTURE_TURN_RIGHT90,
	ACT_GESTURE_TURN_LEFT45_FLAT,
	ACT_GESTURE_TURN_RIGHT45_FLAT,
	ACT_GESTURE_TURN_LEFT90_FLAT,
	ACT_GESTURE_TURN_RIGHT90_FLAT,

	// HALF-LIFE 1 compatability stuff goes here. Temporary!
	ACT_BARNACLE_HIT,		// barnacle tongue hits a monster
	ACT_BARNACLE_PULL,		// barnacle is lifting the monster ( loop )
	ACT_BARNACLE_CHOMP,		// barnacle latches on to the monster
	ACT_BARNACLE_CHEW,		// barnacle is holding the monster in its mouth ( loop )

	// Sometimes, you just want to set an NPC's sequence to a sequence that doesn't actually
	// have an activity. The AI will reset the NPC's sequence to whatever its IDEAL activity
	// is, though. So if you set ideal activity to DO_NOT_DISTURB, the AI will not interfere
	// with the NPC's current sequence. (SJB)
	ACT_DO_NOT_DISTURB,

	// viewmodel (weapon) activities
	// FIXME: move these to the specific viewmodels, no need to make global
	ACT_VM_DRAW,
	ACT_VM_HOLSTER,
	ACT_VM_IDLE,
	ACT_VM_FIDGET,
	ACT_VM_PULLBACK,
	ACT_VM_PULLBACK_HIGH,
	ACT_VM_PULLBACK_LOW,
	ACT_VM_THROW,
	ACT_VM_PULLPIN,
	ACT_VM_PRIMARYATTACK,		// fire
	ACT_VM_SECONDARYATTACK,		// alt. fire
	ACT_VM_RELOAD,			
	ACT_VM_RELOAD_START,			
	ACT_VM_RELOAD_FINISH,			
	ACT_VM_DRYFIRE,				// fire with no ammo loaded.
	ACT_VM_HITLEFT,				// bludgeon, swing to left - hit (primary attk)
	ACT_VM_HITLEFT2,			// bludgeon, swing to left - hit (secondary attk)
	ACT_VM_HITRIGHT,			// bludgeon, swing to right - hit (primary attk)
	ACT_VM_HITRIGHT2,			// bludgeon, swing to right - hit (secondary attk)
	ACT_VM_HITCENTER,			// bludgeon, swing center - hit (primary attk)
	ACT_VM_HITCENTER2,			// bludgeon, swing center - hit (secondary attk)
	ACT_VM_MISSLEFT,			// bludgeon, swing to left - miss (primary attk)
	ACT_VM_MISSLEFT2,			// bludgeon, swing to left - miss (secondary attk)
	ACT_VM_MISSRIGHT,			// bludgeon, swing to right - miss (primary attk)
	ACT_VM_MISSRIGHT2,			// bludgeon, swing to right - miss (secondary attk)
	ACT_VM_MISSCENTER,			// bludgeon, swing center - miss (primary attk)
	ACT_VM_MISSCENTER2,			// bludgeon, swing center - miss (secondary attk)
	ACT_VM_HAULBACK,			// bludgeon, haul the weapon back for a hard strike (secondary attk)
	ACT_VM_SWINGHARD,			// bludgeon, release the hard strike (secondary attk)
	ACT_VM_SWINGMISS,
	ACT_VM_SWINGHIT,
	ACT_VM_IDLE_TO_LOWERED,
	ACT_VM_IDLE_LOWERED,
	ACT_VM_LOWERED_TO_IDLE,
	ACT_VM_RECOIL1,
	ACT_VM_RECOIL2,
	ACT_VM_RECOIL3,
	ACT_VM_PICKUP,
	ACT_VM_RELEASE,
	
	ACT_VM_ATTACH_SILENCER,
	ACT_VM_DETACH_SILENCER,

	// TF2 Scout Pack
	ACT_VM_DRAW_SPECIAL,
	ACT_VM_HOLSTER_SPECIAL,
	ACT_VM_IDLE_SPECIAL,
	ACT_VM_PULLBACK_SPECIAL,
	ACT_VM_PRIMARYATTACK_SPECIAL,
	ACT_VM_SECONDARYATTACK_SPECIAL,
	ACT_VM_HITCENTER_SPECIAL,
	ACT_VM_SWINGHARD_SPECIAL,
	ACT_VM_IDLE_TO_LOWERED_SPECIAL,
	ACT_VM_IDLE_LOWERED_SPECIAL,
	ACT_VM_LOWERED_TO_IDLE_SPECIAL,

	ACT_FISTS_VM_HITLEFT,
	ACT_FISTS_VM_HITRIGHT,
	ACT_FISTS_VM_SWINGHARD,
	ACT_FISTS_VM_IDLE,
	ACT_FISTS_VM_DRAW,

//===========================
// HL2 Specific Activities
//===========================
	// SLAM	Specialty Activities
	ACT_SLAM_STICKWALL_IDLE,
	ACT_SLAM_STICKWALL_ND_IDLE,
	ACT_SLAM_STICKWALL_ATTACH,
	ACT_SLAM_STICKWALL_ATTACH2,
	ACT_SLAM_STICKWALL_ND_ATTACH,
	ACT_SLAM_STICKWALL_ND_ATTACH2,
	ACT_SLAM_STICKWALL_DETONATE,
	ACT_SLAM_STICKWALL_DETONATOR_HOLSTER,
	ACT_SLAM_STICKWALL_DRAW, 
	ACT_SLAM_STICKWALL_ND_DRAW, 
	ACT_SLAM_STICKWALL_TO_THROW, 
	ACT_SLAM_STICKWALL_TO_THROW_ND, 
	ACT_SLAM_STICKWALL_TO_TRIPMINE_ND,
	ACT_SLAM_THROW_IDLE,
	ACT_SLAM_THROW_ND_IDLE,
	ACT_SLAM_THROW_THROW,
	ACT_SLAM_THROW_THROW2,
	ACT_SLAM_THROW_THROW_ND,
	ACT_SLAM_THROW_THROW_ND2,
	ACT_SLAM_THROW_DRAW, 
	ACT_SLAM_THROW_ND_DRAW,
	ACT_SLAM_THROW_TO_STICKWALL, 
	ACT_SLAM_THROW_TO_STICKWALL_ND, 
  	ACT_SLAM_THROW_DETONATE,
  	ACT_SLAM_THROW_DETONATOR_HOLSTER,
	ACT_SLAM_THROW_TO_TRIPMINE_ND,
	ACT_SLAM_TRIPMINE_IDLE,
	ACT_SLAM_TRIPMINE_DRAW, 
	ACT_SLAM_TRIPMINE_ATTACH, 
	ACT_SLAM_TRIPMINE_ATTACH2, 
	ACT_SLAM_TRIPMINE_TO_STICKWALL_ND,
	ACT_SLAM_TRIPMINE_TO_THROW_ND,
	ACT_SLAM_DETONATOR_IDLE, 
	ACT_SLAM_DETONATOR_DRAW, 
	ACT_SLAM_DETONATOR_DETONATE,
	ACT_SLAM_DETONATOR_HOLSTER,
	ACT_SLAM_DETONATOR_STICKWALL_DRAW,
	ACT_SLAM_DETONATOR_THROW_DRAW,

	// Shotgun Specialty Activities
	ACT_SHOTGUN_RELOAD_START,
	ACT_SHOTGUN_RELOAD_FINISH,
	ACT_SHOTGUN_PUMP,

	// SMG2 special activities
	ACT_SMG2_IDLE2,
	ACT_SMG2_FIRE2,
	ACT_SMG2_DRAW2,
	ACT_SMG2_RELOAD2,
	ACT_SMG2_DRYFIRE2,
	ACT_SMG2_TOAUTO,
	ACT_SMG2_TOBURST,
	
	// Physcannon special activities
	ACT_PHYSCANNON_UPGRADE,

	// weapon override activities
	ACT_RANGE_ATTACK_AR1,
	ACT_RANGE_ATTACK_AR2,
	ACT_RANGE_ATTACK_AR2_LOW,
	ACT_RANGE_ATTACK_AR2_GRENADE,
	ACT_RANGE_ATTACK_HMG1,
	ACT_RANGE_ATTACK_ML,
	ACT_RANGE_ATTACK_SMG1,
	ACT_RANGE_ATTACK_SMG1_LOW,
	ACT_RANGE_ATTACK_SMG2,
	ACT_RANGE_ATTACK_SHOTGUN,
	ACT_RANGE_ATTACK_SHOTGUN_LOW,
	ACT_RANGE_ATTACK_PISTOL,
	ACT_RANGE_ATTACK_PISTOL_LOW,
	ACT_RANGE_ATTACK_SLAM,
	ACT_RANGE_ATTACK_TRIPWIRE,
	ACT_RANGE_ATTACK_THROW,
	ACT_RANGE_ATTACK_SNIPER_RIFLE,
	ACT_RANGE_ATTACK_RPG,
	ACT_MELEE_ATTACK_SWING,

	ACT_RANGE_AIM_LOW,
	ACT_RANGE_AIM_SMG1_LOW,
	ACT_RANGE_AIM_PISTOL_LOW,
	ACT_RANGE_AIM_AR2_LOW,

	ACT_COVER_PISTOL_LOW,
	ACT_COVER_SMG1_LOW,

	// weapon override activities
	ACT_GESTURE_RANGE_ATTACK_AR1,
	ACT_GESTURE_RANGE_ATTACK_AR2,
	ACT_GESTURE_RANGE_ATTACK_AR2_GRENADE,
	ACT_GESTURE_RANGE_ATTACK_HMG1,
	ACT_GESTURE_RANGE_ATTACK_ML,
	ACT_GESTURE_RANGE_ATTACK_SMG1,
	ACT_GESTURE_RANGE_ATTACK_SMG1_LOW,
	ACT_GESTURE_RANGE_ATTACK_SMG2,
	ACT_GESTURE_RANGE_ATTACK_SHOTGUN,
	ACT_GESTURE_RANGE_ATTACK_PISTOL,
	ACT_GESTURE_RANGE_ATTACK_PISTOL_LOW,
	ACT_GESTURE_RANGE_ATTACK_SLAM,
	ACT_GESTURE_RANGE_ATTACK_TRIPWIRE,
	ACT_GESTURE_RANGE_ATTACK_THROW,
	ACT_GESTURE_RANGE_ATTACK_SNIPER_RIFLE,
	ACT_GESTURE_MELEE_ATTACK_SWING,

	ACT_IDLE_RIFLE,
	ACT_IDLE_SMG1,
	ACT_IDLE_ANGRY_SMG1,
	ACT_IDLE_PISTOL,
	ACT_IDLE_ANGRY_PISTOL,
	ACT_IDLE_ANGRY_SHOTGUN,
	ACT_IDLE_STEALTH_PISTOL,

	ACT_IDLE_PACKAGE,
	ACT_WALK_PACKAGE,
	ACT_IDLE_SUITCASE,
	ACT_WALK_SUITCASE,

	ACT_IDLE_SMG1_RELAXED,
	ACT_IDLE_SMG1_STIMULATED,
	ACT_WALK_RIFLE_RELAXED,
	ACT_RUN_RIFLE_RELAXED,
	ACT_WALK_RIFLE_STIMULATED,
	ACT_RUN_RIFLE_STIMULATED,

	ACT_IDLE_AIM_RIFLE_STIMULATED,
	ACT_WALK_AIM_RIFLE_STIMULATED,
	ACT_RUN_AIM_RIFLE_STIMULATED,

	ACT_IDLE_SHOTGUN_RELAXED,
	ACT_IDLE_SHOTGUN_STIMULATED,
	ACT_IDLE_SHOTGUN_AGITATED,

	// Policing activities
	ACT_WALK_ANGRY,
	ACT_POLICE_HARASS1,
	ACT_POLICE_HARASS2,

	// Manned guns
	ACT_IDLE_MANNEDGUN,
		
	// Melee weapon
	ACT_IDLE_MELEE,
	ACT_IDLE_ANGRY_MELEE,

	// RPG activities
	ACT_IDLE_RPG_RELAXED,
	ACT_IDLE_RPG, 
	ACT_IDLE_ANGRY_RPG,
	ACT_COVER_LOW_RPG, 
	ACT_WALK_RPG,
	ACT_RUN_RPG, 
	ACT_WALK_CROUCH_RPG, 
	ACT_RUN_CROUCH_RPG, 
	ACT_WALK_RPG_RELAXED, 
	ACT_RUN_RPG_RELAXED, 

	ACT_WALK_RIFLE,
	ACT_WALK_AIM_RIFLE,
	ACT_WALK_CROUCH_RIFLE,
	ACT_WALK_CROUCH_AIM_RIFLE,
	ACT_RUN_RIFLE,
	ACT_RUN_AIM_RIFLE,
	ACT_RUN_CROUCH_RIFLE,
	ACT_RUN_CROUCH_AIM_RIFLE,
	ACT_RUN_STEALTH_PISTOL,

	ACT_WALK_AIM_SHOTGUN,
	ACT_RUN_AIM_SHOTGUN,

	ACT_WALK_PISTOL,
	ACT_RUN_PISTOL,
	ACT_WALK_AIM_PISTOL,
	ACT_RUN_AIM_PISTOL,
	ACT_WALK_STEALTH_PISTOL,
	ACT_WALK_AIM_STEALTH_PISTOL,
	ACT_RUN_AIM_STEALTH_PISTOL,

	// Reloads
	ACT_RELOAD_PISTOL,
	ACT_RELOAD_PISTOL_LOW,
	ACT_RELOAD_SMG1,
	ACT_RELOAD_SMG1_LOW,
	ACT_RELOAD_SHOTGUN,
	ACT_RELOAD_SHOTGUN_LOW,

	ACT_GESTURE_RELOAD,
	ACT_GESTURE_RELOAD_PISTOL,
	ACT_GESTURE_RELOAD_SMG1,
	ACT_GESTURE_RELOAD_SHOTGUN,

	// Busy animations
	ACT_BUSY_LEAN_LEFT,
	ACT_BUSY_LEAN_LEFT_ENTRY,
	ACT_BUSY_LEAN_LEFT_EXIT,
	ACT_BUSY_LEAN_BACK,
	ACT_BUSY_LEAN_BACK_ENTRY,
	ACT_BUSY_LEAN_BACK_EXIT,
	ACT_BUSY_SIT_GROUND,
	ACT_BUSY_SIT_GROUND_ENTRY,
	ACT_BUSY_SIT_GROUND_EXIT,
	ACT_BUSY_SIT_CHAIR,
	ACT_BUSY_SIT_CHAIR_ENTRY,
	ACT_BUSY_SIT_CHAIR_EXIT,
	ACT_BUSY_STAND,
	ACT_BUSY_QUEUE,

	// Dodge animations
	ACT_DUCK_DODGE,

	// For NPCs being lifted/eaten by barnacles:
	// being swallowed by a barnacle
	ACT_DIE_BARNACLE_SWALLOW,  
	 // being lifted by a barnacle
	ACT_GESTURE_BARNACLE_STRANGLE, 

	ACT_PHYSCANNON_DETACH,	// An activity to be played if we're picking this up with the physcannon
	ACT_PHYSCANNON_ANIMATE, // An activity to be played by an object being picked up with the physcannon, but has different behavior to DETACH
	ACT_PHYSCANNON_ANIMATE_PRE,	// An activity to be played by an object being picked up with the physcannon, before playing the ACT_PHYSCANNON_ANIMATE
	ACT_PHYSCANNON_ANIMATE_POST,// An activity to be played by an object being picked up with the physcannon, after playing the ACT_PHYSCANNON_ANIMATE

	ACT_DIE_FRONTSIDE,
	ACT_DIE_RIGHTSIDE,
	ACT_DIE_BACKSIDE,
	ACT_DIE_LEFTSIDE,

	ACT_OPEN_DOOR,

	// Dynamic interactions
	ACT_DI_ALYX_ZOMBIE_MELEE,
	ACT_DI_ALYX_ZOMBIE_TORSO_MELEE,
	ACT_DI_ALYX_HEADCRAB_MELEE,
	ACT_DI_ALYX_ANTLION,

	ACT_DI_ALYX_ZOMBIE_SHOTGUN64,
	ACT_DI_ALYX_ZOMBIE_SHOTGUN26,

	ACT_READINESS_RELAXED_TO_STIMULATED,
	ACT_READINESS_RELAXED_TO_STIMULATED_WALK,
	ACT_READINESS_AGITATED_TO_STIMULATED,
	ACT_READINESS_STIMULATED_TO_RELAXED,

	ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED,
	ACT_READINESS_PISTOL_RELAXED_TO_STIMULATED_WALK,
	ACT_READINESS_PISTOL_AGITATED_TO_STIMULATED,
	ACT_READINESS_PISTOL_STIMULATED_TO_RELAXED,

	ACT_IDLE_CARRY,
	ACT_WALK_CARRY,

//===========================
// TF2 Specific Activities
//===========================
	ACT_STARTDYING,
	ACT_DYINGLOOP,
	ACT_DYINGTODEAD,

	ACT_RIDE_MANNED_GUN,

	// All viewmodels
	ACT_VM_SPRINT_ENTER,
	ACT_VM_SPRINT_IDLE,
	ACT_VM_SPRINT_LEAVE,

	// Looping weapon firing
	ACT_FIRE_START,
	ACT_FIRE_LOOP,
	ACT_FIRE_END,

	ACT_CROUCHING_GRENADEIDLE,
	ACT_CROUCHING_GRENADEREADY,
	ACT_CROUCHING_PRIMARYATTACK,
	ACT_OVERLAY_GRENADEIDLE,
	ACT_OVERLAY_GRENADEREADY,
	ACT_OVERLAY_PRIMARYATTACK,
	ACT_OVERLAY_SHIELD_UP,
	ACT_OVERLAY_SHIELD_DOWN,
	ACT_OVERLAY_SHIELD_UP_IDLE,
	ACT_OVERLAY_SHIELD_ATTACK,
	ACT_OVERLAY_SHIELD_KNOCKBACK,
	ACT_SHIELD_UP,
	ACT_SHIELD_DOWN,
	ACT_SHIELD_UP_IDLE,
	ACT_SHIELD_ATTACK,
	ACT_SHIELD_KNOCKBACK,
	ACT_CROUCHING_SHIELD_UP,
	ACT_CROUCHING_SHIELD_DOWN,
	ACT_CROUCHING_SHIELD_UP_IDLE,
	ACT_CROUCHING_SHIELD_ATTACK,
	ACT_CROUCHING_SHIELD_KNOCKBACK,

	// turning in place
	ACT_TURNRIGHT45,
	ACT_TURNLEFT45,

	ACT_TURN,

	ACT_OBJ_ASSEMBLING,
	ACT_OBJ_DISMANTLING,
	ACT_OBJ_STARTUP,
	ACT_OBJ_RUNNING,
	ACT_OBJ_IDLE,
	ACT_OBJ_PLACING,
	ACT_OBJ_DETERIORATING,
	ACT_OBJ_UPGRADING,

	// Deploy
	ACT_DEPLOY,
	ACT_DEPLOY_IDLE,
	ACT_UNDEPLOY,

//===========================
// HL1 Specific Activities
//===========================
	// Grenades
	ACT_GRENADE_ROLL,
	ACT_GRENADE_TOSS,

	// Hand grenade
	ACT_HANDGRENADE_THROW1,
	ACT_HANDGRENADE_THROW2,
	ACT_HANDGRENADE_THROW3,

	// Shotgun
	ACT_SHOTGUN_IDLE_DEEP,
	ACT_SHOTGUN_IDLE4,

	// Glock
	ACT_GLOCK_SHOOTEMPTY,
	ACT_GLOCK_SHOOT_RELOAD,

	// RPG
	ACT_RPG_DRAW_UNLOADED,
	ACT_RPG_HOLSTER_UNLOADED,
	ACT_RPG_IDLE_UNLOADED,
	ACT_RPG_FIDGET_UNLOADED,

	// Crossbow
	ACT_CROSSBOW_DRAW_UNLOADED,
	ACT_CROSSBOW_IDLE_UNLOADED,
	ACT_CROSSBOW_FIDGET_UNLOADED,

	// Gauss
	ACT_GAUSS_SPINUP,
	ACT_GAUSS_SPINCYCLE,

	// Tripmine
	ACT_TRIPMINE_GROUND,
	ACT_TRIPMINE_WORLD,

//===========================
// CSPort Specific Activities
//===========================

	ACT_VM_PRIMARYATTACK_SILENCED,		// fire
	ACT_VM_RELOAD_SILENCED,
	ACT_VM_DRYFIRE_SILENCED,				// fire with no ammo loaded.
	ACT_VM_IDLE_SILENCED,
	ACT_VM_DRAW_SILENCED,
	ACT_VM_IDLE_EMPTY_LEFT,
	ACT_VM_DRYFIRE_LEFT,

	ACT_PLAYER_IDLE_FIRE,
	ACT_PLAYER_CROUCH_FIRE,
	ACT_PLAYER_CROUCH_WALK_FIRE,
	ACT_PLAYER_WALK_FIRE,
	ACT_PLAYER_RUN_FIRE,
	
	ACT_IDLETORUN,
	ACT_RUNTOIDLE,
	

//===========================
// DoD Specific Activities
//===========================
	ACT_SPRINT,
	
	ACT_GET_DOWN_STAND,
	ACT_GET_UP_STAND,
	ACT_GET_DOWN_CROUCH,
	ACT_GET_UP_CROUCH,
	ACT_PRONE_FORWARD,
	ACT_PRONE_IDLE,

	ACT_DEEPIDLE1,
	ACT_DEEPIDLE2,
	ACT_DEEPIDLE3,
	ACT_DEEPIDLE4,

	ACT_VM_RELOAD_DEPLOYED, 
	ACT_VM_RELOAD_IDLE,

	ACT_VM_DRAW_DEPLOYED,

	//Weapon is empty activities
	ACT_VM_DRAW_EMPTY,
	ACT_VM_PRIMARYATTACK_EMPTY,
	ACT_VM_RELOAD_EMPTY,
	ACT_VM_IDLE_EMPTY,
	ACT_VM_IDLE_DEPLOYED_EMPTY,

	ACT_VM_IDLE_8,
	ACT_VM_IDLE_7,
	ACT_VM_IDLE_6,
	ACT_VM_IDLE_5,
	ACT_VM_IDLE_4,
	ACT_VM_IDLE_3,
	ACT_VM_IDLE_2,
	ACT_VM_IDLE_1,

	ACT_VM_IDLE_DEPLOYED,
	ACT_VM_IDLE_DEPLOYED_8,
	ACT_VM_IDLE_DEPLOYED_7,
	ACT_VM_IDLE_DEPLOYED_6,
	ACT_VM_IDLE_DEPLOYED_5,
	ACT_VM_IDLE_DEPLOYED_4,
	ACT_VM_IDLE_DEPLOYED_3,
	ACT_VM_IDLE_DEPLOYED_2,
	ACT_VM_IDLE_DEPLOYED_1,

	// Animation from prone idle to standing/crouch idle. Number designates bullets left
	ACT_VM_UNDEPLOY,
	ACT_VM_UNDEPLOY_8,
	ACT_VM_UNDEPLOY_7,
	ACT_VM_UNDEPLOY_6,
	ACT_VM_UNDEPLOY_5,
	ACT_VM_UNDEPLOY_4,
	ACT_VM_UNDEPLOY_3,
	ACT_VM_UNDEPLOY_2,
	ACT_VM_UNDEPLOY_1,
	ACT_VM_UNDEPLOY_EMPTY,

	// Animation from standing/crouch idle to prone idle. Number designates bullets left
	ACT_VM_DEPLOY,
	ACT_VM_DEPLOY_8,
	ACT_VM_DEPLOY_7,
	ACT_VM_DEPLOY_6,
	ACT_VM_DEPLOY_5,
	ACT_VM_DEPLOY_4,
	ACT_VM_DEPLOY_3,
	ACT_VM_DEPLOY_2,
	ACT_VM_DEPLOY_1,
	ACT_VM_DEPLOY_EMPTY,

	// Shooting animations for standing/crouch position.  Number designates bullets left at START of animation
	ACT_VM_PRIMARYATTACK_8,
	ACT_VM_PRIMARYATTACK_7,
	ACT_VM_PRIMARYATTACK_6,
	ACT_VM_PRIMARYATTACK_5,
	ACT_VM_PRIMARYATTACK_4,
	ACT_VM_PRIMARYATTACK_3,
	ACT_VM_PRIMARYATTACK_2,
	ACT_VM_PRIMARYATTACK_1,

	// Shooting animations for prone position. Number designates bullets left at START of animation
	ACT_VM_PRIMARYATTACK_DEPLOYED,
	ACT_VM_PRIMARYATTACK_DEPLOYED_8,
	ACT_VM_PRIMARYATTACK_DEPLOYED_7,
	ACT_VM_PRIMARYATTACK_DEPLOYED_6, 
	ACT_VM_PRIMARYATTACK_DEPLOYED_5,
	ACT_VM_PRIMARYATTACK_DEPLOYED_4,
	ACT_VM_PRIMARYATTACK_DEPLOYED_3,
	ACT_VM_PRIMARYATTACK_DEPLOYED_2,
	ACT_VM_PRIMARYATTACK_DEPLOYED_1,
	ACT_VM_PRIMARYATTACK_DEPLOYED_EMPTY,

	// Player anim ACTs
	ACT_DOD_DEPLOYED,
	ACT_DOD_PRONE_DEPLOYED,
	ACT_DOD_IDLE_ZOOMED,
	ACT_DOD_WALK_ZOOMED,
	ACT_DOD_CROUCH_ZOOMED,
	ACT_DOD_CROUCHWALK_ZOOMED,
	ACT_DOD_PRONE_ZOOMED,
	ACT_DOD_PRONE_FORWARD_ZOOMED,
	ACT_DOD_PRIMARYATTACK_DEPLOYED,
	ACT_DOD_PRIMARYATTACK_PRONE_DEPLOYED,
	ACT_DOD_RELOAD_DEPLOYED,
	ACT_DOD_RELOAD_PRONE_DEPLOYED,	
	ACT_DOD_PRIMARYATTACK_PRONE,
	ACT_DOD_SECONDARYATTACK_PRONE,
	ACT_DOD_RELOAD_CROUCH,
	ACT_DOD_RELOAD_PRONE,
	ACT_DOD_STAND_IDLE,
	ACT_DOD_STAND_AIM,
	ACT_DOD_CROUCH_IDLE,
	ACT_DOD_CROUCH_AIM,
	ACT_DOD_CROUCHWALK_IDLE,
	ACT_DOD_CROUCHWALK_AIM,
	ACT_DOD_WALK_IDLE,
	ACT_DOD_WALK_AIM,
	ACT_DOD_RUN_IDLE,
	ACT_DOD_RUN_AIM,

	// Positions
	ACT_DOD_STAND_AIM_PISTOL,
	ACT_DOD_CROUCH_AIM_PISTOL,
	ACT_DOD_CROUCHWALK_AIM_PISTOL,
	ACT_DOD_WALK_AIM_PISTOL,
	ACT_DOD_RUN_AIM_PISTOL,
	ACT_DOD_PRONE_AIM_PISTOL,
	ACT_DOD_STAND_IDLE_PISTOL,
	ACT_DOD_CROUCH_IDLE_PISTOL,
	ACT_DOD_CROUCHWALK_IDLE_PISTOL,
	ACT_DOD_WALK_IDLE_PISTOL,
	ACT_DOD_RUN_IDLE_PISTOL,
	ACT_DOD_SPRINT_IDLE_PISTOL,
	ACT_DOD_PRONEWALK_IDLE_PISTOL,

	ACT_DOD_STAND_AIM_C96,
	ACT_DOD_CROUCH_AIM_C96,
	ACT_DOD_CROUCHWALK_AIM_C96,
	ACT_DOD_WALK_AIM_C96,
	ACT_DOD_RUN_AIM_C96,
	ACT_DOD_PRONE_AIM_C96,
	ACT_DOD_STAND_IDLE_C96,
	ACT_DOD_CROUCH_IDLE_C96,
	ACT_DOD_CROUCHWALK_IDLE_C96,
	ACT_DOD_WALK_IDLE_C96,
	ACT_DOD_RUN_IDLE_C96,
	ACT_DOD_SPRINT_IDLE_C96,
	ACT_DOD_PRONEWALK_IDLE_C96,

	ACT_DOD_STAND_AIM_RIFLE,
	ACT_DOD_CROUCH_AIM_RIFLE,
	ACT_DOD_CROUCHWALK_AIM_RIFLE,
	ACT_DOD_WALK_AIM_RIFLE,
	ACT_DOD_RUN_AIM_RIFLE,
	ACT_DOD_PRONE_AIM_RIFLE,
	ACT_DOD_STAND_IDLE_RIFLE,
	ACT_DOD_CROUCH_IDLE_RIFLE,
	ACT_DOD_CROUCHWALK_IDLE_RIFLE,
	ACT_DOD_WALK_IDLE_RIFLE,
	ACT_DOD_RUN_IDLE_RIFLE,
	ACT_DOD_SPRINT_IDLE_RIFLE,
	ACT_DOD_PRONEWALK_IDLE_RIFLE,

	ACT_DOD_STAND_AIM_BOLT,
	ACT_DOD_CROUCH_AIM_BOLT,
	ACT_DOD_CROUCHWALK_AIM_BOLT,
	ACT_DOD_WALK_AIM_BOLT,
	ACT_DOD_RUN_AIM_BOLT,
	ACT_DOD_PRONE_AIM_BOLT,
	ACT_DOD_STAND_IDLE_BOLT,
	ACT_DOD_CROUCH_IDLE_BOLT,
	ACT_DOD_CROUCHWALK_IDLE_BOLT,
	ACT_DOD_WALK_IDLE_BOLT,
	ACT_DOD_RUN_IDLE_BOLT,
	ACT_DOD_SPRINT_IDLE_BOLT,
	ACT_DOD_PRONEWALK_IDLE_BOLT,

	ACT_DOD_STAND_AIM_TOMMY,
	ACT_DOD_CROUCH_AIM_TOMMY,
	ACT_DOD_CROUCHWALK_AIM_TOMMY,
	ACT_DOD_WALK_AIM_TOMMY,
	ACT_DOD_RUN_AIM_TOMMY,
	ACT_DOD_PRONE_AIM_TOMMY,
	ACT_DOD_STAND_IDLE_TOMMY,
	ACT_DOD_CROUCH_IDLE_TOMMY,
	ACT_DOD_CROUCHWALK_IDLE_TOMMY,
	ACT_DOD_WALK_IDLE_TOMMY,
	ACT_DOD_RUN_IDLE_TOMMY,
	ACT_DOD_SPRINT_IDLE_TOMMY,
	ACT_DOD_PRONEWALK_IDLE_TOMMY,

	ACT_DOD_STAND_AIM_MP40,
	ACT_DOD_CROUCH_AIM_MP40,
	ACT_DOD_CROUCHWALK_AIM_MP40,
	ACT_DOD_WALK_AIM_MP40,
	ACT_DOD_RUN_AIM_MP40,
	ACT_DOD_PRONE_AIM_MP40,
	ACT_DOD_STAND_IDLE_MP40,
	ACT_DOD_CROUCH_IDLE_MP40,
	ACT_DOD_CROUCHWALK_IDLE_MP40,
	ACT_DOD_WALK_IDLE_MP40,
	ACT_DOD_RUN_IDLE_MP40,
	ACT_DOD_SPRINT_IDLE_MP40,
	ACT_DOD_PRONEWALK_IDLE_MP40,

	ACT_DOD_STAND_AIM_MP44,
	ACT_DOD_CROUCH_AIM_MP44,
	ACT_DOD_CROUCHWALK_AIM_MP44,
	ACT_DOD_WALK_AIM_MP44,
	ACT_DOD_RUN_AIM_MP44,
	ACT_DOD_PRONE_AIM_MP44,
	ACT_DOD_STAND_IDLE_MP44,
	ACT_DOD_CROUCH_IDLE_MP44,
	ACT_DOD_CROUCHWALK_IDLE_MP44,
	ACT_DOD_WALK_IDLE_MP44,
	ACT_DOD_RUN_IDLE_MP44,
	ACT_DOD_SPRINT_IDLE_MP44,
	ACT_DOD_PRONEWALK_IDLE_MP44,

	ACT_DOD_STAND_AIM_GREASE,
	ACT_DOD_CROUCH_AIM_GREASE,
	ACT_DOD_CROUCHWALK_AIM_GREASE,
	ACT_DOD_WALK_AIM_GREASE,
	ACT_DOD_RUN_AIM_GREASE,
	ACT_DOD_PRONE_AIM_GREASE,
	ACT_DOD_STAND_IDLE_GREASE,
	ACT_DOD_CROUCH_IDLE_GREASE,
	ACT_DOD_CROUCHWALK_IDLE_GREASE,
	ACT_DOD_WALK_IDLE_GREASE,
	ACT_DOD_RUN_IDLE_GREASE,
	ACT_DOD_SPRINT_IDLE_GREASE,
	ACT_DOD_PRONEWALK_IDLE_GREASE,

	ACT_DOD_STAND_AIM_MG,
	ACT_DOD_CROUCH_AIM_MG,
	ACT_DOD_CROUCHWALK_AIM_MG,
	ACT_DOD_WALK_AIM_MG,
	ACT_DOD_RUN_AIM_MG,
	ACT_DOD_PRONE_AIM_MG,
	ACT_DOD_STAND_IDLE_MG,
	ACT_DOD_CROUCH_IDLE_MG,
	ACT_DOD_CROUCHWALK_IDLE_MG,
	ACT_DOD_WALK_IDLE_MG,
	ACT_DOD_RUN_IDLE_MG,
	ACT_DOD_SPRINT_IDLE_MG,
	ACT_DOD_PRONEWALK_IDLE_MG,

	ACT_DOD_STAND_AIM_30CAL,
	ACT_DOD_CROUCH_AIM_30CAL,
	ACT_DOD_CROUCHWALK_AIM_30CAL,
	ACT_DOD_WALK_AIM_30CAL,
	ACT_DOD_RUN_AIM_30CAL,
	ACT_DOD_PRONE_AIM_30CAL,
	ACT_DOD_STAND_IDLE_30CAL,
	ACT_DOD_CROUCH_IDLE_30CAL,
	ACT_DOD_CROUCHWALK_IDLE_30CAL,
	ACT_DOD_WALK_IDLE_30CAL,
	ACT_DOD_RUN_IDLE_30CAL,
	ACT_DOD_SPRINT_IDLE_30CAL,
	ACT_DOD_PRONEWALK_IDLE_30CAL,

	ACT_DOD_STAND_AIM_GREN_FRAG,
	ACT_DOD_CROUCH_AIM_GREN_FRAG,
	ACT_DOD_CROUCHWALK_AIM_GREN_FRAG,
	ACT_DOD_WALK_AIM_GREN_FRAG,
	ACT_DOD_RUN_AIM_GREN_FRAG,
	ACT_DOD_PRONE_AIM_GREN_FRAG,
	ACT_DOD_SPRINT_AIM_GREN_FRAG,
	ACT_DOD_PRONEWALK_AIM_GREN_FRAG,
	ACT_DOD_STAND_AIM_GREN_STICK,
	ACT_DOD_CROUCH_AIM_GREN_STICK,
	ACT_DOD_CROUCHWALK_AIM_GREN_STICK,
	ACT_DOD_WALK_AIM_GREN_STICK,
	ACT_DOD_RUN_AIM_GREN_STICK,
	ACT_DOD_PRONE_AIM_GREN_STICK,
	ACT_DOD_SPRINT_AIM_GREN_STICK,
	ACT_DOD_PRONEWALK_AIM_GREN_STICK,

	ACT_DOD_STAND_AIM_KNIFE,
	ACT_DOD_CROUCH_AIM_KNIFE,
	ACT_DOD_CROUCHWALK_AIM_KNIFE,
	ACT_DOD_WALK_AIM_KNIFE,
	ACT_DOD_RUN_AIM_KNIFE,
	ACT_DOD_PRONE_AIM_KNIFE,
	ACT_DOD_SPRINT_AIM_KNIFE,
	ACT_DOD_PRONEWALK_AIM_KNIFE,

	ACT_DOD_STAND_AIM_SPADE,
	ACT_DOD_CROUCH_AIM_SPADE,
	ACT_DOD_CROUCHWALK_AIM_SPADE,
	ACT_DOD_WALK_AIM_SPADE,
	ACT_DOD_RUN_AIM_SPADE,
	ACT_DOD_PRONE_AIM_SPADE,
	ACT_DOD_SPRINT_AIM_SPADE,
	ACT_DOD_PRONEWALK_AIM_SPADE,

	ACT_DOD_STAND_AIM_BAZOOKA,
	ACT_DOD_CROUCH_AIM_BAZOOKA,
	ACT_DOD_CROUCHWALK_AIM_BAZOOKA,
	ACT_DOD_WALK_AIM_BAZOOKA,
	ACT_DOD_RUN_AIM_BAZOOKA,
	ACT_DOD_PRONE_AIM_BAZOOKA,
	ACT_DOD_STAND_IDLE_BAZOOKA,
	ACT_DOD_CROUCH_IDLE_BAZOOKA,
	ACT_DOD_CROUCHWALK_IDLE_BAZOOKA,
	ACT_DOD_WALK_IDLE_BAZOOKA,
	ACT_DOD_RUN_IDLE_BAZOOKA,
	ACT_DOD_SPRINT_IDLE_BAZOOKA,
	ACT_DOD_PRONEWALK_IDLE_BAZOOKA,

	ACT_DOD_STAND_AIM_PSCHRECK,
	ACT_DOD_CROUCH_AIM_PSCHRECK,
	ACT_DOD_CROUCHWALK_AIM_PSCHRECK,
	ACT_DOD_WALK_AIM_PSCHRECK,
	ACT_DOD_RUN_AIM_PSCHRECK,
	ACT_DOD_PRONE_AIM_PSCHRECK,
	ACT_DOD_STAND_IDLE_PSCHRECK,
	ACT_DOD_CROUCH_IDLE_PSCHRECK,
	ACT_DOD_CROUCHWALK_IDLE_PSCHRECK,
	ACT_DOD_WALK_IDLE_PSCHRECK,
	ACT_DOD_RUN_IDLE_PSCHRECK,
	ACT_DOD_SPRINT_IDLE_PSCHRECK,
	ACT_DOD_PRONEWALK_IDLE_PSCHRECK,

	ACT_DOD_STAND_AIM_BAR,
	ACT_DOD_CROUCH_AIM_BAR,
	ACT_DOD_CROUCHWALK_AIM_BAR,
	ACT_DOD_WALK_AIM_BAR,
	ACT_DOD_RUN_AIM_BAR,
	ACT_DOD_PRONE_AIM_BAR,
	ACT_DOD_STAND_IDLE_BAR,
	ACT_DOD_CROUCH_IDLE_BAR,
	ACT_DOD_CROUCHWALK_IDLE_BAR,
	ACT_DOD_WALK_IDLE_BAR,
	ACT_DOD_RUN_IDLE_BAR,
	ACT_DOD_SPRINT_IDLE_BAR,
	ACT_DOD_PRONEWALK_IDLE_BAR,

	// Zoomed aims
	ACT_DOD_STAND_ZOOM_RIFLE,
	ACT_DOD_CROUCH_ZOOM_RIFLE,
	ACT_DOD_CROUCHWALK_ZOOM_RIFLE,
	ACT_DOD_WALK_ZOOM_RIFLE,
	ACT_DOD_RUN_ZOOM_RIFLE,
	ACT_DOD_PRONE_ZOOM_RIFLE,

	ACT_DOD_STAND_ZOOM_BOLT,
	ACT_DOD_CROUCH_ZOOM_BOLT,
	ACT_DOD_CROUCHWALK_ZOOM_BOLT,
	ACT_DOD_WALK_ZOOM_BOLT,
	ACT_DOD_RUN_ZOOM_BOLT,
	ACT_DOD_PRONE_ZOOM_BOLT,

	ACT_DOD_STAND_ZOOM_BAZOOKA,
	ACT_DOD_CROUCH_ZOOM_BAZOOKA,
	ACT_DOD_CROUCHWALK_ZOOM_BAZOOKA,
	ACT_DOD_WALK_ZOOM_BAZOOKA,
	ACT_DOD_RUN_ZOOM_BAZOOKA,
	ACT_DOD_PRONE_ZOOM_BAZOOKA,

	ACT_DOD_STAND_ZOOM_PSCHRECK,
	ACT_DOD_CROUCH_ZOOM_PSCHRECK,
	ACT_DOD_CROUCHWALK_ZOOM_PSCHRECK,
	ACT_DOD_WALK_ZOOM_PSCHRECK,
	ACT_DOD_RUN_ZOOM_PSCHRECK,
	ACT_DOD_PRONE_ZOOM_PSCHRECK,

	// Deployed Aim
	ACT_DOD_DEPLOY_RIFLE,
	ACT_DOD_DEPLOY_TOMMY,
	ACT_DOD_DEPLOY_MG,
	ACT_DOD_DEPLOY_30CAL,

	// Prone Deployed Aim
	ACT_DOD_PRONE_DEPLOY_RIFLE ,
	ACT_DOD_PRONE_DEPLOY_TOMMY,
	ACT_DOD_PRONE_DEPLOY_MG,
	ACT_DOD_PRONE_DEPLOY_30CAL,

	// Attacks

	// Rifle
	ACT_DOD_PRIMARYATTACK_RIFLE,
	ACT_DOD_SECONDARYATTACK_RIFLE,
	ACT_DOD_PRIMARYATTACK_PRONE_RIFLE,
	ACT_DOD_SECONDARYATTACK_PRONE_RIFLE,
	ACT_DOD_PRIMARYATTACK_PRONE_DEPLOYED_RIFLE,
	ACT_DOD_PRIMARYATTACK_DEPLOYED_RIFLE,

	// Bolt
	ACT_DOD_PRIMARYATTACK_BOLT,
	ACT_DOD_SECONDARYATTACK_BOLT,
	ACT_DOD_PRIMARYATTACK_PRONE_BOLT ,
	ACT_DOD_SECONDARYATTACK_PRONE_BOLT ,

	// Tommy
	ACT_DOD_PRIMARYATTACK_TOMMY,
	ACT_DOD_PRIMARYATTACK_PRONE_TOMMY,
	ACT_DOD_SECONDARYATTACK_TOMMY,
	ACT_DOD_SECONDARYATTACK_PRONE_TOMMY,

	// MP40
	ACT_DOD_PRIMARYATTACK_MP40,
	ACT_DOD_PRIMARYATTACK_PRONE_MP40 ,
	ACT_DOD_SECONDARYATTACK_MP40,
	ACT_DOD_SECONDARYATTACK_PRONE_MP40 ,

	// MP44
	ACT_DOD_PRIMARYATTACK_MP44,
	ACT_DOD_PRIMARYATTACK_PRONE_MP44 ,

	// Greasegun
	ACT_DOD_PRIMARYATTACK_GREASE,
	ACT_DOD_PRIMARYATTACK_PRONE_GREASE ,

	// Pistols (Colt, Luger)
	ACT_DOD_PRIMARYATTACK_PISTOL,
	ACT_DOD_PRIMARYATTACK_PRONE_PISTOL ,
	ACT_DOD_PRIMARYATTACK_C96,
	ACT_DOD_PRIMARYATTACK_PRONE_C96,

	// Mgs (mg42, mg34)
	ACT_DOD_PRIMARYATTACK_MG,
	ACT_DOD_PRIMARYATTACK_PRONE_MG ,
	ACT_DOD_PRIMARYATTACK_PRONE_DEPLOYED_MG ,
	ACT_DOD_PRIMARYATTACK_DEPLOYED_MG ,

	// 30cal
	ACT_DOD_PRIMARYATTACK_30CAL,
	ACT_DOD_PRIMARYATTACK_PRONE_30CAL,
	ACT_DOD_PRIMARYATTACK_DEPLOYED_30CAL,
	ACT_DOD_PRIMARYATTACK_PRONE_DEPLOYED_30CAL ,

	// Grenades
	ACT_DOD_PRIMARYATTACK_GREN_FRAG,
	ACT_DOD_PRIMARYATTACK_PRONE_GREN_FRAG,
	ACT_DOD_PRIMARYATTACK_GREN_STICK,
	ACT_DOD_PRIMARYATTACK_PRONE_GREN_STICK,

	// Knife
	ACT_DOD_PRIMARYATTACK_KNIFE,
	ACT_DOD_PRIMARYATTACK_PRONE_KNIFE,

	// Spade
	ACT_DOD_PRIMARYATTACK_SPADE,
	ACT_DOD_PRIMARYATTACK_PRONE_SPADE,

	// Bazooka
	ACT_DOD_PRIMARYATTACK_BAZOOKA,
	ACT_DOD_PRIMARYATTACK_PRONE_BAZOOKA,

	// Pschreck
	ACT_DOD_PRIMARYATTACK_PSCHRECK,
	ACT_DOD_PRIMARYATTACK_PRONE_PSCHRECK ,

	// Bar
	ACT_DOD_PRIMARYATTACK_BAR,
	ACT_DOD_PRIMARYATTACK_PRONE_BAR,

	// Reloads
	ACT_DOD_RELOAD_GARAND,
	ACT_DOD_RELOAD_K43,
	ACT_DOD_RELOAD_BAR,
	ACT_DOD_RELOAD_MP40,
	ACT_DOD_RELOAD_MP44,
	ACT_DOD_RELOAD_BOLT,
	ACT_DOD_RELOAD_M1CARBINE,
	ACT_DOD_RELOAD_TOMMY,
	ACT_DOD_RELOAD_GREASEGUN,
	ACT_DOD_RELOAD_PISTOL,
	ACT_DOD_RELOAD_FG42,
	ACT_DOD_RELOAD_RIFLE,
	ACT_DOD_RELOAD_RIFLEGRENADE,
	ACT_DOD_RELOAD_C96,

	// Crouch
	ACT_DOD_RELOAD_CROUCH_BAR,
	ACT_DOD_RELOAD_CROUCH_RIFLE,
	ACT_DOD_RELOAD_CROUCH_RIFLEGRENADE,
	ACT_DOD_RELOAD_CROUCH_BOLT,
	ACT_DOD_RELOAD_CROUCH_MP44,
	ACT_DOD_RELOAD_CROUCH_MP40,
	ACT_DOD_RELOAD_CROUCH_TOMMY,
	ACT_DOD_RELOAD_CROUCH_BAZOOKA,
	ACT_DOD_RELOAD_CROUCH_PSCHRECK,
	ACT_DOD_RELOAD_CROUCH_PISTOL,
	ACT_DOD_RELOAD_CROUCH_M1CARBINE,
	ACT_DOD_RELOAD_CROUCH_C96,

	// Bazookas
	ACT_DOD_RELOAD_BAZOOKA,
	ACT_DOD_ZOOMLOAD_BAZOOKA,
	ACT_DOD_RELOAD_PSCHRECK,
	ACT_DOD_ZOOMLOAD_PSCHRECK,

	// Deployed
	ACT_DOD_RELOAD_DEPLOYED_FG42,
	ACT_DOD_RELOAD_DEPLOYED_30CAL,
	ACT_DOD_RELOAD_DEPLOYED_MG,
	ACT_DOD_RELOAD_DEPLOYED_MG34,
	ACT_DOD_RELOAD_DEPLOYED_BAR,

	// Prone
	ACT_DOD_RELOAD_PRONE_PISTOL,
	ACT_DOD_RELOAD_PRONE_GARAND,
	ACT_DOD_RELOAD_PRONE_M1CARBINE,
	ACT_DOD_RELOAD_PRONE_BOLT,
	ACT_DOD_RELOAD_PRONE_K43,
	ACT_DOD_RELOAD_PRONE_MP40,
	ACT_DOD_RELOAD_PRONE_MP44,
	ACT_DOD_RELOAD_PRONE_BAR,
	ACT_DOD_RELOAD_PRONE_GREASEGUN,
	ACT_DOD_RELOAD_PRONE_TOMMY,
	ACT_DOD_RELOAD_PRONE_FG42,
	ACT_DOD_RELOAD_PRONE_RIFLE,
	ACT_DOD_RELOAD_PRONE_RIFLEGRENADE,
	ACT_DOD_RELOAD_PRONE_C96,

	// Prone bazooka
	ACT_DOD_RELOAD_PRONE_BAZOOKA,
	ACT_DOD_ZOOMLOAD_PRONE_BAZOOKA,
	ACT_DOD_RELOAD_PRONE_PSCHRECK,
	ACT_DOD_ZOOMLOAD_PRONE_PSCHRECK,

	// Prone deployed
	ACT_DOD_RELOAD_PRONE_DEPLOYED_BAR,
	ACT_DOD_RELOAD_PRONE_DEPLOYED_FG42,
	ACT_DOD_RELOAD_PRONE_DEPLOYED_30CAL,
	ACT_DOD_RELOAD_PRONE_DEPLOYED_MG,
	ACT_DOD_RELOAD_PRONE_DEPLOYED_MG34,

	// Prone zoomed aim
	ACT_DOD_PRONE_ZOOM_FORWARD_RIFLE,
	ACT_DOD_PRONE_ZOOM_FORWARD_BOLT,
	ACT_DOD_PRONE_ZOOM_FORWARD_BAZOOKA,
	ACT_DOD_PRONE_ZOOM_FORWARD_PSCHRECK,

	// Crouch attack
	ACT_DOD_PRIMARYATTACK_CROUCH,
	ACT_DOD_PRIMARYATTACK_CROUCH_SPADE,
	ACT_DOD_PRIMARYATTACK_CROUCH_KNIFE,
	ACT_DOD_PRIMARYATTACK_CROUCH_GREN_FRAG,
	ACT_DOD_PRIMARYATTACK_CROUCH_GREN_STICK,
	ACT_DOD_SECONDARYATTACK_CROUCH,
	ACT_DOD_SECONDARYATTACK_CROUCH_TOMMY,
	ACT_DOD_SECONDARYATTACK_CROUCH_MP40,

	// Hand Signals
	ACT_DOD_HS_IDLE,
	ACT_DOD_HS_CROUCH,
	ACT_DOD_HS_IDLE_30CAL,
	ACT_DOD_HS_IDLE_BAZOOKA,
	ACT_DOD_HS_IDLE_PSCHRECK,
	ACT_DOD_HS_IDLE_KNIFE,
	ACT_DOD_HS_IDLE_MG42,
	ACT_DOD_HS_IDLE_PISTOL,
	ACT_DOD_HS_IDLE_STICKGRENADE,
	ACT_DOD_HS_IDLE_TOMMY,
	ACT_DOD_HS_IDLE_MP44,
	ACT_DOD_HS_IDLE_K98,
	ACT_DOD_HS_CROUCH_30CAL,
	ACT_DOD_HS_CROUCH_BAZOOKA,
	ACT_DOD_HS_CROUCH_PSCHRECK,
	ACT_DOD_HS_CROUCH_KNIFE,
	ACT_DOD_HS_CROUCH_MG42,
	ACT_DOD_HS_CROUCH_PISTOL,
	ACT_DOD_HS_CROUCH_STICKGRENADE,
	ACT_DOD_HS_CROUCH_TOMMY,
	ACT_DOD_HS_CROUCH_MP44,
	ACT_DOD_HS_CROUCH_K98,

	ACT_DOD_STAND_IDLE_TNT,
	ACT_DOD_CROUCH_IDLE_TNT,
	ACT_DOD_CROUCHWALK_IDLE_TNT,
	ACT_DOD_WALK_IDLE_TNT,
	ACT_DOD_RUN_IDLE_TNT,
	ACT_DOD_SPRINT_IDLE_TNT,
	ACT_DOD_PRONEWALK_IDLE_TNT,

	ACT_DOD_PLANT_TNT,
	ACT_DOD_DEFUSE_TNT,

// HL2MP
	ACT_HL2MP_IDLE,
	ACT_HL2MP_RUN,
	ACT_HL2MP_IDLE_CROUCH,
	ACT_HL2MP_WALK_CROUCH,
	ACT_HL2MP_GESTURE_RANGE_ATTACK,
	ACT_HL2MP_GESTURE_RELOAD,
	ACT_HL2MP_JUMP,
	
	ACT_HL2MP_IDLE_PISTOL,
	ACT_HL2MP_RUN_PISTOL,
	ACT_HL2MP_IDLE_CROUCH_PISTOL,
	ACT_HL2MP_WALK_CROUCH_PISTOL,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_PISTOL,
	ACT_HL2MP_GESTURE_RELOAD_PISTOL,
	ACT_HL2MP_JUMP_PISTOL,

	ACT_HL2MP_IDLE_SMG1,
	ACT_HL2MP_RUN_SMG1,
	ACT_HL2MP_IDLE_CROUCH_SMG1,
	ACT_HL2MP_WALK_CROUCH_SMG1,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_SMG1,
	ACT_HL2MP_GESTURE_RELOAD_SMG1,
	ACT_HL2MP_JUMP_SMG1,

  	ACT_HL2MP_IDLE_AR2,
	ACT_HL2MP_RUN_AR2,
	ACT_HL2MP_IDLE_CROUCH_AR2,
	ACT_HL2MP_WALK_CROUCH_AR2,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_AR2,
	ACT_HL2MP_GESTURE_RELOAD_AR2,
	ACT_HL2MP_JUMP_AR2,

  	ACT_HL2MP_IDLE_SHOTGUN,
	ACT_HL2MP_RUN_SHOTGUN,
	ACT_HL2MP_IDLE_CROUCH_SHOTGUN,
	ACT_HL2MP_WALK_CROUCH_SHOTGUN,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_SHOTGUN,
	ACT_HL2MP_GESTURE_RELOAD_SHOTGUN,
	ACT_HL2MP_JUMP_SHOTGUN,

  	ACT_HL2MP_IDLE_RPG,
	ACT_HL2MP_RUN_RPG,
	ACT_HL2MP_IDLE_CROUCH_RPG,
	ACT_HL2MP_WALK_CROUCH_RPG,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_RPG,
	ACT_HL2MP_GESTURE_RELOAD_RPG,
	ACT_HL2MP_JUMP_RPG,

  	ACT_HL2MP_IDLE_GRENADE,
	ACT_HL2MP_RUN_GRENADE,
	ACT_HL2MP_IDLE_CROUCH_GRENADE,
	ACT_HL2MP_WALK_CROUCH_GRENADE,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_GRENADE,
	ACT_HL2MP_GESTURE_RELOAD_GRENADE,
	ACT_HL2MP_JUMP_GRENADE,

  	ACT_HL2MP_IDLE_PHYSGUN,
	ACT_HL2MP_RUN_PHYSGUN,
	ACT_HL2MP_IDLE_CROUCH_PHYSGUN,
	ACT_HL2MP_WALK_CROUCH_PHYSGUN,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_PHYSGUN,
	ACT_HL2MP_GESTURE_RELOAD_PHYSGUN,
	ACT_HL2MP_JUMP_PHYSGUN,

  	ACT_HL2MP_IDLE_CROSSBOW,
	ACT_HL2MP_RUN_CROSSBOW,
	ACT_HL2MP_IDLE_CROUCH_CROSSBOW,
	ACT_HL2MP_WALK_CROUCH_CROSSBOW,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_CROSSBOW,
	ACT_HL2MP_GESTURE_RELOAD_CROSSBOW,
	ACT_HL2MP_JUMP_CROSSBOW,

  	ACT_HL2MP_IDLE_MELEE,
	ACT_HL2MP_RUN_MELEE,
	ACT_HL2MP_IDLE_CROUCH_MELEE,
	ACT_HL2MP_WALK_CROUCH_MELEE,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_MELEE,
	ACT_HL2MP_GESTURE_RELOAD_MELEE,
	ACT_HL2MP_JUMP_MELEE,

	ACT_HL2MP_IDLE_SLAM,
	ACT_HL2MP_RUN_SLAM,
	ACT_HL2MP_IDLE_CROUCH_SLAM,
	ACT_HL2MP_WALK_CROUCH_SLAM,
	ACT_HL2MP_GESTURE_RANGE_ATTACK_SLAM,
	ACT_HL2MP_GESTURE_RELOAD_SLAM,
	ACT_HL2MP_JUMP_SLAM,

// Portal!
	ACT_VM_FIZZLE,

	// Multiplayer
	ACT_MP_STAND_IDLE,
	ACT_MP_CROUCH_IDLE,
	ACT_MP_CROUCH_DEPLOYED_IDLE,
	ACT_MP_CROUCH_DEPLOYED,
	ACT_MP_CROUCHWALK_DEPLOYED,
	ACT_MP_DEPLOYED_IDLE,
	ACT_MP_RUN,
	ACT_MP_WALK,
	ACT_MP_AIRWALK,
	ACT_MP_CROUCHWALK,
	ACT_MP_SPRINT,
	ACT_MP_JUMP,
	ACT_MP_JUMP_START,
	ACT_MP_JUMP_FLOAT,
	ACT_MP_JUMP_LAND,
	ACT_MP_DOUBLEJUMP,
	ACT_MP_SWIM,
	ACT_MP_DEPLOYED,
	ACT_MP_SWIM_DEPLOYED,
	ACT_MP_VCD,

	ACT_MP_ATTACK_STAND_PRIMARYFIRE,
	ACT_MP_ATTACK_STAND_PRIMARYFIRE_DEPLOYED,
	ACT_MP_ATTACK_STAND_SECONDARYFIRE,
	ACT_MP_ATTACK_STAND_GRENADE,
	ACT_MP_ATTACK_CROUCH_PRIMARYFIRE,
	ACT_MP_ATTACK_CROUCH_PRIMARYFIRE_DEPLOYED,
	ACT_MP_ATTACK_CROUCH_SECONDARYFIRE,
	ACT_MP_ATTACK_CROUCH_GRENADE,
	ACT_MP_ATTACK_SWIM_PRIMARYFIRE,
	ACT_MP_ATTACK_SWIM_SECONDARYFIRE,
	ACT_MP_ATTACK_SWIM_GRENADE,
	ACT_MP_ATTACK_AIRWALK_PRIMARYFIRE,
	ACT_MP_ATTACK_AIRWALK_SECONDARYFIRE,
	ACT_MP_ATTACK_AIRWALK_GRENADE,
	ACT_MP_RELOAD_STAND,
	ACT_MP_RELOAD_STAND_LOOP,
	ACT_MP_RELOAD_STAND_END,
	ACT_MP_RELOAD_CROUCH,
	ACT_MP_RELOAD_CROUCH_LOOP,
	ACT_MP_RELOAD_CROUCH_END,
	ACT_MP_RELOAD_SWIM,
	ACT_MP_RELOAD_SWIM_LOOP,
	ACT_MP_RELOAD_SWIM_END,
	ACT_MP_RELOAD_AIRWALK,
	ACT_MP_RELOAD_AIRWALK_LOOP,
	ACT_MP_RELOAD_AIRWALK_END,
	ACT_MP_ATTACK_STAND_PREFIRE,
	ACT_MP_ATTACK_STAND_POSTFIRE,
	ACT_MP_ATTACK_STAND_STARTFIRE,
	ACT_MP_ATTACK_CROUCH_PREFIRE,
	ACT_MP_ATTACK_CROUCH_POSTFIRE,
	ACT_MP_ATTACK_SWIM_PREFIRE,
	ACT_MP_ATTACK_SWIM_POSTFIRE,

	// Multiplayer - Primary
	ACT_MP_STAND_PRIMARY,
	ACT_MP_CROUCH_PRIMARY,
	ACT_MP_RUN_PRIMARY,
	ACT_MP_WALK_PRIMARY,
	ACT_MP_AIRWALK_PRIMARY,
	ACT_MP_CROUCHWALK_PRIMARY,
	ACT_MP_JUMP_PRIMARY,
	ACT_MP_JUMP_START_PRIMARY,
	ACT_MP_JUMP_FLOAT_PRIMARY,
	ACT_MP_JUMP_LAND_PRIMARY,
	ACT_MP_SWIM_PRIMARY,
	ACT_MP_DEPLOYED_PRIMARY,
	ACT_MP_SWIM_DEPLOYED_PRIMARY,
	ACT_MP_CROUCHWALK_DEPLOYED_PRIMARY,
	ACT_MP_CROUCH_DEPLOYED_IDLE_PRIMARY,

	ACT_MP_ATTACK_STAND_PRIMARY,		// RUN, WALK
	ACT_MP_ATTACK_STAND_PRIMARY_DEPLOYED,
	ACT_MP_ATTACK_CROUCH_PRIMARY,		// CROUCHWALK
	ACT_MP_ATTACK_CROUCH_PRIMARY_DEPLOYED,
	ACT_MP_ATTACK_SWIM_PRIMARY,
	ACT_MP_ATTACK_AIRWALK_PRIMARY,

	ACT_MP_RELOAD_STAND_PRIMARY,		// RUN, WALK
	ACT_MP_RELOAD_STAND_PRIMARY_LOOP,
	ACT_MP_RELOAD_STAND_PRIMARY_END,
	ACT_MP_RELOAD_CROUCH_PRIMARY,		// CROUCHWALK
	ACT_MP_RELOAD_CROUCH_PRIMARY_LOOP,
	ACT_MP_RELOAD_CROUCH_PRIMARY_END,
	ACT_MP_RELOAD_SWIM_PRIMARY,
	ACT_MP_RELOAD_SWIM_PRIMARY_LOOP,
	ACT_MP_RELOAD_SWIM_PRIMARY_END,
	ACT_MP_RELOAD_AIRWALK_PRIMARY,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_LOOP,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_END,

	ACT_MP_RELOAD_STAND_PRIMARY_2,
	ACT_MP_RELOAD_STAND_PRIMARY_LOOP_2,
	ACT_MP_RELOAD_STAND_PRIMARY_END_2,	
	ACT_MP_RELOAD_CROUCH_PRIMARY_2,	
	ACT_MP_RELOAD_CROUCH_PRIMARY_LOOP_2,
	ACT_MP_RELOAD_CROUCH_PRIMARY_END_2,
	ACT_MP_RELOAD_SWIM_PRIMARY_2,
	ACT_MP_RELOAD_SWIM_PRIMARY_LOOP_2,
	ACT_MP_RELOAD_SWIM_PRIMARY_END_2,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_2,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_LOOP_2,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_END_2,

	// PRIMARY ALT
	ACT_MP_ATTACK_STAND_PRIMARY_ALT,
	ACT_MP_ATTACK_CROUCH_PRIMARY_ALT,
	ACT_MP_ATTACK_SWIM_PRIMARY_ALT,
	ACT_MP_RELOAD_STAND_PRIMARY_ALT,
	ACT_MP_RELOAD_CROUCH_PRIMARY_ALT,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_ALT,
	ACT_MP_RELOAD_STAND_PRIMARY_LOOP_ALT,
	ACT_MP_RELOAD_CROUCH_PRIMARY_LOOP_ALT,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_LOOP_ALT,
	ACT_MP_RELOAD_STAND_PRIMARY_END_ALT,
	ACT_MP_RELOAD_CROUCH_PRIMARY_END_ALT,
	ACT_MP_RELOAD_AIRWALK_PRIMARY_END_ALT,
	ACT_MP_RELOAD_SWIM_PRIMARY_ALT,
	ACT_MP_ATTACK_STAND_PRIMARY_SUPER,
	ACT_MP_ATTACK_CROUCH_PRIMARY_SUPER,
	ACT_MP_ATTACK_SWIM_PRIMARY_SUPER,

	ACT_MP_ATTACK_STAND_GRENADE_PRIMARY,		// RUN, WALK
	ACT_MP_ATTACK_CROUCH_GRENADE_PRIMARY,		// CROUCHWALK
	ACT_MP_ATTACK_SWIM_GRENADE_PRIMARY,
	ACT_MP_ATTACK_AIRWALK_GRENADE_PRIMARY,

	// Secondary
	ACT_MP_STAND_SECONDARY,
	ACT_MP_CROUCH_SECONDARY,
	ACT_MP_RUN_SECONDARY,
	ACT_MP_WALK_SECONDARY,
	ACT_MP_AIRWALK_SECONDARY,
	ACT_MP_CROUCHWALK_SECONDARY,
	ACT_MP_JUMP_SECONDARY,
	ACT_MP_JUMP_START_SECONDARY,
	ACT_MP_JUMP_FLOAT_SECONDARY,
	ACT_MP_JUMP_LAND_SECONDARY,
	ACT_MP_SWIM_SECONDARY,

	ACT_MP_ATTACK_STAND_SECONDARY,		// RUN, WALK
	ACT_MP_ATTACK_CROUCH_SECONDARY,		// CROUCHWALK
	ACT_MP_ATTACK_SWIM_SECONDARY,
	ACT_MP_ATTACK_AIRWALK_SECONDARY,

	ACT_MP_RELOAD_STAND_SECONDARY,		// RUN, WALK
	ACT_MP_RELOAD_STAND_SECONDARY_LOOP,
	ACT_MP_RELOAD_STAND_SECONDARY_END,
	ACT_MP_RELOAD_CROUCH_SECONDARY,		// CROUCHWALK
	ACT_MP_RELOAD_CROUCH_SECONDARY_LOOP,
	ACT_MP_RELOAD_CROUCH_SECONDARY_END,
	ACT_MP_RELOAD_SWIM_SECONDARY,
	ACT_MP_RELOAD_SWIM_SECONDARY_LOOP,
	ACT_MP_RELOAD_SWIM_SECONDARY_END,
	ACT_MP_RELOAD_AIRWALK_SECONDARY,
	ACT_MP_RELOAD_AIRWALK_SECONDARY_LOOP,
	ACT_MP_RELOAD_AIRWALK_SECONDARY_END,

	ACT_MP_RELOAD_STAND_SECONDARY_2,
	ACT_MP_RELOAD_CROUCH_SECONDARY_2,
	ACT_MP_RELOAD_SWIM_SECONDARY_2,
	ACT_MP_RELOAD_AIRWALK_SECONDARY_2,

	ACT_MP_ATTACK_STAND_GRENADE_SECONDARY,		// RUN, WALK
	ACT_MP_ATTACK_CROUCH_GRENADE_SECONDARY,		// CROUCHWALK
	ACT_MP_ATTACK_SWIM_GRENADE_SECONDARY,
	ACT_MP_ATTACK_AIRWALK_GRENADE_SECONDARY,

	// Secondary2
	ACT_MP_STAND_SECONDARY2,
	ACT_MP_CROUCH_SECONDARY2,
	ACT_MP_RUN_SECONDARY2,
	ACT_MP_WALK_SECONDARY2,
	ACT_MP_AIRWALK_SECONDARY2,
	ACT_MP_CROUCHWALK_SECONDARY2,
	ACT_MP_JUMP_SECONDARY2,
	ACT_MP_JUMP_START_SECONDARY2,
	ACT_MP_JUMP_FLOAT_SECONDARY2,
	ACT_MP_JUMP_LAND_SECONDARY2,
	ACT_MP_SWIM_SECONDARY2,

	ACT_MP_ATTACK_STAND_SECONDARY2,		// RUN, WALK
	ACT_MP_ATTACK_CROUCH_SECONDARY2,		// CROUCHWALK
	ACT_MP_ATTACK_SWIM_SECONDARY2,
	ACT_MP_ATTACK_AIRWALK_SECONDARY2,

	ACT_MP_RELOAD_STAND_SECONDARY2,		// RUN, WALK
	ACT_MP_RELOAD_STAND_SECONDARY2_LOOP,
	ACT_MP_RELOAD_STAND_SECONDARY2_END,
	ACT_MP_RELOAD_CROUCH_SECONDARY2,		// CROUCHWALK
	ACT_MP_RELOAD_CROUCH_SECONDARY2_LOOP,
	ACT_MP_RELOAD_CROUCH_SECONDARY2_END,
	ACT_MP_RELOAD_SWIM_SECONDARY2,
	ACT_MP_RELOAD_SWIM_SECONDARY2_LOOP,
	ACT_MP_RELOAD_SWIM_SECONDARY2_END,
	ACT_MP_RELOAD_AIRWALK_SECONDARY2,
	ACT_MP_RELOAD_AIRWALK_SECONDARY2_LOOP,
	ACT_MP_RELOAD_AIRWALK_SECONDARY2_END,

	// Melee
	ACT_MP_STAND_MELEE,
	ACT_MP_CROUCH_MELEE,
	ACT_MP_RUN_MELEE,
	ACT_MP_WALK_MELEE,
	ACT_MP_AIRWALK_MELEE,
	ACT_MP_CROUCHWALK_MELEE,
	ACT_MP_JUMP_MELEE,
	ACT_MP_JUMP_START_MELEE,
	ACT_MP_JUMP_FLOAT_MELEE,
	ACT_MP_JUMP_LAND_MELEE,
	ACT_MP_SWIM_MELEE,

	ACT_MP_ATTACK_STAND_MELEE,		// RUN, WALK
	ACT_MP_ATTACK_STAND_MELEE_SECONDARY,
	ACT_MP_ATTACK_CROUCH_MELEE,		// CROUCHWALK
	ACT_MP_ATTACK_CROUCH_MELEE_SECONDARY,
	ACT_MP_ATTACK_SWIM_MELEE,
	ACT_MP_ATTACK_AIRWALK_MELEE,

	ACT_MP_ATTACK_STAND_GRENADE_MELEE,		// RUN, WALK
	ACT_MP_ATTACK_CROUCH_GRENADE_MELEE,		// CROUCHWALK
	ACT_MP_ATTACK_SWIM_GRENADE_MELEE,
	ACT_MP_ATTACK_AIRWALK_GRENADE_MELEE,

	// Item1
	ACT_MP_STAND_ITEM1,
	ACT_MP_CROUCH_ITEM1,
	ACT_MP_RUN_ITEM1,
	ACT_MP_WALK_ITEM1,
	ACT_MP_AIRWALK_ITEM1,
	ACT_MP_CROUCHWALK_ITEM1,
	ACT_MP_JUMP_ITEM1,
	ACT_MP_JUMP_START_ITEM1,
	ACT_MP_JUMP_FLOAT_ITEM1,
	ACT_MP_JUMP_LAND_ITEM1,
	ACT_MP_SWIM_ITEM1,

	ACT_MP_ATTACK_STAND_ITEM1,		// RUN, WALK
	ACT_MP_ATTACK_STAND_ITEM1_SECONDARY,
	ACT_MP_ATTACK_CROUCH_ITEM1,		// CROUCHWALK
	ACT_MP_ATTACK_CROUCH_ITEM1_SECONDARY,
	ACT_MP_ATTACK_SWIM_ITEM1,
	ACT_MP_ATTACK_AIRWALK_ITEM1,

	ACT_MP_DEPLOYED_ITEM1,
	ACT_MP_DEPLOYED_IDLE_ITEM1,
	ACT_MP_CROUCHWALK_DEPLOYED_ITEM1,
	ACT_MP_CROUCH_DEPLOYED_IDLE_ITEM1,
	ACT_MP_ATTACK_STAND_PRIMARY_DEPLOYED_ITEM1,
	ACT_MP_ATTACK_CROUCH_PRIMARY_DEPLOYED_ITEM1,

	// Item2
	ACT_MP_STAND_ITEM2,
	ACT_MP_CROUCH_ITEM2,
	ACT_MP_RUN_ITEM2,
	ACT_MP_WALK_ITEM2,
	ACT_MP_AIRWALK_ITEM2,
	ACT_MP_CROUCHWALK_ITEM2,
	ACT_MP_JUMP_ITEM2,
	ACT_MP_JUMP_START_ITEM2,
	ACT_MP_JUMP_FLOAT_ITEM2,
	ACT_MP_JUMP_LAND_ITEM2,
	ACT_MP_SWIM_ITEM2,

	ACT_MP_ATTACK_STAND_ITEM2,		// RUN, WALK
	ACT_MP_ATTACK_STAND_ITEM2_SECONDARY,
	ACT_MP_ATTACK_CROUCH_ITEM2,		// CROUCHWALK
	ACT_MP_ATTACK_CROUCH_ITEM2_SECONDARY,
	ACT_MP_ATTACK_SWIM_ITEM2,
	ACT_MP_ATTACK_AIRWALK_ITEM2,

	ACT_MP_ATTACK_STAND_HARD_ITEM2,	
	ACT_MP_ATTACK_CROUCH_HARD_ITEM2,
	ACT_MP_ATTACK_SWIM_HARD_ITEM2,

	ACT_MP_DEPLOYED_ITEM2,
	ACT_MP_DEPLOYED_IDLE_ITEM2,
	ACT_MP_CROUCHWALK_DEPLOYED_ITEM2,
	ACT_MP_CROUCH_DEPLOYED_IDLE_ITEM2,
	ACT_MP_ATTACK_STAND_PRIMARY_DEPLOYED_ITEM2,
	ACT_MP_ATTACK_CROUCH_PRIMARY_DEPLOYED_ITEM2,

	ACT_MP_RELOAD_STAND_ITEM2,		// RUN, WALK
	ACT_MP_RELOAD_STAND_ITEM2_LOOP,
	ACT_MP_RELOAD_STAND_ITEM2_END,
	ACT_MP_RELOAD_CROUCH_ITEM2,		// CROUCHWALK
	ACT_MP_RELOAD_CROUCH_ITEM2_LOOP,
	ACT_MP_RELOAD_CROUCH_ITEM2_END,
	ACT_MP_RELOAD_SWIM_ITEM2,
	ACT_MP_RELOAD_SWIM_ITEM2_LOOP,
	ACT_MP_RELOAD_SWIM_ITEM2_END,
	ACT_MP_RELOAD_AIRWALK_ITEM2,
	ACT_MP_RELOAD_AIRWALK_ITEM2_LOOP,
	ACT_MP_RELOAD_AIRWALK_ITEM2_END,
	ACT_MP_RELOAD_NO_AMMO_ITEM2,

	ACT_MP_ATTACK_STAND_GRENADE_ITEM2,		// RUN, WALK
	ACT_MP_ATTACK_CROUCH_GRENADE_ITEM2,		// CROUCHWALK
	ACT_MP_ATTACK_SWIM_GRENADE_ITEM2,
	ACT_MP_ATTACK_AIRWALK_GRENADE_ITEM2,

	// Passtime
	ACT_MP_STAND_PASSTIME,
	ACT_MP_RUN_PASSTIME,
	ACT_MP_CROUCHWALK_PASSTIME,

	// Flinches
	ACT_MP_GESTURE_FLINCH,
	ACT_MP_GESTURE_FLINCH_PRIMARY,
	ACT_MP_GESTURE_FLINCH_SECONDARY,
	ACT_MP_GESTURE_FLINCH_MELEE,
	ACT_MP_GESTURE_FLINCH_ITEM1,
	ACT_MP_GESTURE_FLINCH_ITEM2,

	ACT_MP_GESTURE_FLINCH_HEAD,
	ACT_MP_GESTURE_FLINCH_CHEST,
	ACT_MP_GESTURE_FLINCH_STOMACH,
	ACT_MP_GESTURE_FLINCH_LEFTARM,
	ACT_MP_GESTURE_FLINCH_RIGHTARM,
	ACT_MP_GESTURE_FLINCH_LEFTLEG,
	ACT_MP_GESTURE_FLINCH_RIGHTLEG,

// Team Fortress specific - medic heal, medic infect, etc.....
	ACT_MP_GRENADE1_DRAW,
	ACT_MP_GRENADE1_IDLE,
	ACT_MP_GRENADE1_ATTACK,
	ACT_MP_GRENADE2_DRAW,
	ACT_MP_GRENADE2_IDLE,
	ACT_MP_GRENADE2_ATTACK,

	ACT_MP_PRIMARY_GRENADE1_DRAW,
	ACT_MP_PRIMARY_GRENADE1_IDLE,
	ACT_MP_PRIMARY_GRENADE1_ATTACK,
	ACT_MP_PRIMARY_GRENADE2_DRAW,
	ACT_MP_PRIMARY_GRENADE2_IDLE,
	ACT_MP_PRIMARY_GRENADE2_ATTACK,

	ACT_MP_SECONDARY_GRENADE1_DRAW,
	ACT_MP_SECONDARY_GRENADE1_IDLE,
	ACT_MP_SECONDARY_GRENADE1_ATTACK,
	ACT_MP_SECONDARY_GRENADE2_DRAW,
	ACT_MP_SECONDARY_GRENADE2_IDLE,
	ACT_MP_SECONDARY_GRENADE2_ATTACK,

	ACT_MP_MELEE_GRENADE1_DRAW,
	ACT_MP_MELEE_GRENADE1_IDLE,
	ACT_MP_MELEE_GRENADE1_ATTACK,
	ACT_MP_MELEE_GRENADE2_DRAW,
	ACT_MP_MELEE_GRENADE2_IDLE,
	ACT_MP_MELEE_GRENADE2_ATTACK,

	ACT_MP_ITEM1_GRENADE1_DRAW,
	ACT_MP_ITEM1_GRENADE1_IDLE,
	ACT_MP_ITEM1_GRENADE1_ATTACK,
	ACT_MP_ITEM1_GRENADE2_DRAW,
	ACT_MP_ITEM1_GRENADE2_IDLE,
	ACT_MP_ITEM1_GRENADE2_ATTACK,

	ACT_MP_ITEM2_GRENADE1_DRAW,
	ACT_MP_ITEM2_GRENADE1_IDLE,
	ACT_MP_ITEM2_GRENADE1_ATTACK,
	ACT_MP_ITEM2_GRENADE2_DRAW,
	ACT_MP_ITEM2_GRENADE2_IDLE,
	ACT_MP_ITEM2_GRENADE2_ATTACK,

	// Building
	ACT_MP_STAND_BUILDING,
	ACT_MP_CROUCH_BUILDING,
	ACT_MP_RUN_BUILDING,
	ACT_MP_WALK_BUILDING,
	ACT_MP_AIRWALK_BUILDING,
	ACT_MP_CROUCHWALK_BUILDING,
	ACT_MP_JUMP_BUILDING,
	ACT_MP_JUMP_START_BUILDING,
	ACT_MP_JUMP_FLOAT_BUILDING,
	ACT_MP_JUMP_LAND_BUILDING,
	ACT_MP_SWIM_BUILDING,

	ACT_MP_ATTACK_STAND_BUILDING,		// RUN, WALK
	ACT_MP_ATTACK_CROUCH_BUILDING,		// CROUCHWALK
	ACT_MP_ATTACK_SWIM_BUILDING,
	ACT_MP_ATTACK_AIRWALK_BUILDING,

	ACT_MP_ATTACK_STAND_GRENADE_BUILDING,		// RUN, WALK
	ACT_MP_ATTACK_CROUCH_GRENADE_BUILDING,		// CROUCHWALK
	ACT_MP_ATTACK_SWIM_GRENADE_BUILDING,
	ACT_MP_ATTACK_AIRWALK_GRENADE_BUILDING,

	// Building
	ACT_MP_STAND_BUILDING_DEPLOYED,
	ACT_MP_CROUCH_BUILDING_DEPLOYED,
	ACT_MP_RUN_BUILDING_DEPLOYED,
	ACT_MP_WALK_BUILDING_DEPLOYED,
	ACT_MP_AIRWALK_BUILDING_DEPLOYED,
	ACT_MP_CROUCHWALK_BUILDING_DEPLOYED,
	ACT_MP_JUMP_BUILDING_DEPLOYED,
	ACT_MP_JUMP_START_BUILDING_DEPLOYED,
	ACT_MP_JUMP_FLOAT_BUILDING_DEPLOYED,
	ACT_MP_JUMP_LAND_BUILDING_DEPLOYED,
	ACT_MP_SWIM_BUILDING_DEPLOYED,

	ACT_MP_ATTACK_STAND_BUILDING_DEPLOYED,		// RUN, WALK
	ACT_MP_ATTACK_CROUCH_BUILDING_DEPLOYED,		// CROUCHWALK
	ACT_MP_ATTACK_SWIM_BUILDING_DEPLOYED,
	ACT_MP_ATTACK_AIRWALK_BUILDING_DEPLOYED,

	ACT_MP_ATTACK_STAND_GRENADE_BUILDING_DEPLOYED,		// RUN, WALK
	ACT_MP_ATTACK_CROUCH_GRENADE_BUILDING_DEPLOYED,		// CROUCHWALK
	ACT_MP_ATTACK_SWIM_GRENADE_BUILDING_DEPLOYED,
	ACT_MP_ATTACK_AIRWALK_GRENADE_BUILDING_DEPLOYED,

	ACT_MP_STAND_PDA,
	ACT_MP_CROUCH_PDA,
	ACT_MP_RUN_PDA,
	ACT_MP_WALK_PDA,
	ACT_MP_AIRWALK_PDA,
	ACT_MP_CROUCHWALK_PDA,
	ACT_MP_JUMP_PDA,
	ACT_MP_JUMP_START_PDA,
	ACT_MP_JUMP_FLOAT_PDA,
	ACT_MP_JUMP_LAND_PDA,
	ACT_MP_SWIM_PDA,

	ACT_MP_ATTACK_STAND_PDA,
	ACT_MP_ATTACK_SWIM_PDA,

	ACT_MP_STAND_LOSERSTATE,
	ACT_MP_CROUCH_LOSERSTATE,
	ACT_MP_RUN_LOSERSTATE,
	ACT_MP_WALK_LOSERSTATE,
	ACT_MP_AIRWALK_LOSERSTATE,
	ACT_MP_CROUCHWALK_LOSERSTATE,
	ACT_MP_JUMP_LOSERSTATE,
	ACT_MP_JUMP_START_LOSERSTATE,
	ACT_MP_JUMP_FLOAT_LOSERSTATE,
	ACT_MP_JUMP_LAND_LOSERSTATE,
	ACT_MP_SWIM_LOSERSTATE,
	ACT_MP_DOUBLEJUMP_LOSERSTATE,

	ACT_MP_DOUBLEJUMP_CROUCH,
	ACT_MP_DOUBLEJUMP_CROUCH_PRIMARY,
	ACT_MP_DOUBLEJUMP_CROUCH_SECONDARY,
	ACT_MP_DOUBLEJUMP_CROUCH_MELEE,
	ACT_MP_DOUBLEJUMP_CROUCH_ITEM1,
	ACT_MP_DOUBLEJUMP_CROUCH_ITEM2,
	ACT_MP_DOUBLEJUMP_CROUCH_LOSERSTATE,
	ACT_MP_DOUBLEJUMP_CROUCH_PASSTIME,

	ACT_MP_GESTURE_VC_HANDMOUTH,
	ACT_MP_GESTURE_VC_FINGERPOINT,
	ACT_MP_GESTURE_VC_FISTPUMP,
	ACT_MP_GESTURE_VC_THUMBSUP,
	ACT_MP_GESTURE_VC_NODYES,
	ACT_MP_GESTURE_VC_NODNO,

	ACT_MP_GESTURE_VC_HANDMOUTH_PRIMARY,
	ACT_MP_GESTURE_VC_FINGERPOINT_PRIMARY,
	ACT_MP_GESTURE_VC_FISTPUMP_PRIMARY,
	ACT_MP_GESTURE_VC_THUMBSUP_PRIMARY,
	ACT_MP_GESTURE_VC_NODYES_PRIMARY,
	ACT_MP_GESTURE_VC_NODNO_PRIMARY,

	ACT_MP_GESTURE_VC_HANDMOUTH_SECONDARY,
	ACT_MP_GESTURE_VC_FINGERPOINT_SECONDARY,
	ACT_MP_GESTURE_VC_FISTPUMP_SECONDARY,
	ACT_MP_GESTURE_VC_THUMBSUP_SECONDARY,
	ACT_MP_GESTURE_VC_NODYES_SECONDARY,
	ACT_MP_GESTURE_VC_NODNO_SECONDARY,

	ACT_MP_GESTURE_VC_HANDMOUTH_MELEE,
	ACT_MP_GESTURE_VC_FINGERPOINT_MELEE,
	ACT_MP_GESTURE_VC_FISTPUMP_MELEE,
	ACT_MP_GESTURE_VC_THUMBSUP_MELEE,
	ACT_MP_GESTURE_VC_NODYES_MELEE,
	ACT_MP_GESTURE_VC_NODNO_MELEE,

	ACT_MP_GESTURE_VC_HANDMOUTH_ITEM1,
	ACT_MP_GESTURE_VC_FINGERPOINT_ITEM1,
	ACT_MP_GESTURE_VC_FISTPUMP_ITEM1,
	ACT_MP_GESTURE_VC_THUMBSUP_ITEM1,
	ACT_MP_GESTURE_VC_NODYES_ITEM1,
	ACT_MP_GESTURE_VC_NODNO_ITEM1,

	ACT_MP_GESTURE_VC_HANDMOUTH_ITEM2,
	ACT_MP_GESTURE_VC_FINGERPOINT_ITEM2,
	ACT_MP_GESTURE_VC_FISTPUMP_ITEM2,
	ACT_MP_GESTURE_VC_THUMBSUP_ITEM2,
	ACT_MP_GESTURE_VC_NODYES_ITEM2,
	ACT_MP_GESTURE_VC_NODNO_ITEM2,

	ACT_MP_GESTURE_VC_HANDMOUTH_BUILDING,
	ACT_MP_GESTURE_VC_FINGERPOINT_BUILDING,
	ACT_MP_GESTURE_VC_FISTPUMP_BUILDING,
	ACT_MP_GESTURE_VC_THUMBSUP_BUILDING,
	ACT_MP_GESTURE_VC_NODYES_BUILDING,
	ACT_MP_GESTURE_VC_NODNO_BUILDING,

	ACT_MP_GESTURE_VC_HANDMOUTH_PDA,
	ACT_MP_GESTURE_VC_FINGERPOINT_PDA,
	ACT_MP_GESTURE_VC_FISTPUMP_PDA,
	ACT_MP_GESTURE_VC_THUMBSUP_PDA,
	ACT_MP_GESTURE_VC_NODYES_PDA,
	ACT_MP_GESTURE_VC_NODNO_PDA,

	ACT_MP_STUN_BEGIN,
	ACT_MP_STUN_MIDDLE,
	ACT_MP_STUN_END,

	ACT_MP_PASSTIME_THROW_BEGIN,
	ACT_MP_PASSTIME_THROW_MIDDLE,
	ACT_MP_PASSTIME_THROW_END,
	ACT_MP_PASSTIME_THROW_CANCEL,

	ACT_VM_UNUSABLE,
	ACT_VM_UNUSABLE_TO_USABLE,
	ACT_VM_USABLE_TO_UNUSABLE,

	// Specific viewmodel activities for weapon roles
	ACT_PRIMARY_VM_DRAW,
	ACT_PRIMARY_VM_HOLSTER,
	ACT_PRIMARY_VM_IDLE,
	ACT_PRIMARY_VM_PULLBACK,
	ACT_PRIMARY_VM_PRIMARYATTACK,
	ACT_PRIMARY_VM_SECONDARYATTACK,
	ACT_PRIMARY_VM_RELOAD,			
	ACT_PRIMARY_RELOAD_START,			
	ACT_PRIMARY_RELOAD_FINISH,			
	ACT_PRIMARY_VM_DRYFIRE,		
	ACT_PRIMARY_VM_IDLE_TO_LOWERED,
	ACT_PRIMARY_VM_IDLE_LOWERED,
	ACT_PRIMARY_VM_LOWERED_TO_IDLE,
	ACT_PRIMARY_VM_RELOAD_2,
	ACT_PRIMARY_RELOAD_START_2,		
	ACT_PRIMARY_RELOAD_FINISH_2,
	ACT_PRIMARY_VM_RELOAD_3,
	ACT_PRIMARY_RELOAD_START_3,		
	ACT_PRIMARY_RELOAD_FINISH_3,
	ACT_PRIMARY_VM_PRIMARYATTACK_3,

	ACT_SECONDARY_VM_DRAW,
	ACT_SECONDARY_VM_HOLSTER,
	ACT_SECONDARY_VM_IDLE,
	ACT_SECONDARY_VM_PULLBACK,
	ACT_SECONDARY_VM_PRIMARYATTACK,
	ACT_SECONDARY_VM_SECONDARYATTACK,
	ACT_SECONDARY_VM_RELOAD,			
	ACT_SECONDARY_RELOAD_START,
	ACT_SECONDARY_RELOAD_FINISH,
	ACT_SECONDARY_VM_RELOAD2,			
	ACT_SECONDARY_VM_DRYFIRE,		
	ACT_SECONDARY_VM_IDLE_TO_LOWERED,
	ACT_SECONDARY_VM_IDLE_LOWERED,
	ACT_SECONDARY_VM_LOWERED_TO_IDLE,

	ACT_SECONDARY_VM_DRAW_2,
	ACT_SECONDARY_VM_IDLE_2,
	ACT_SECONDARY_VM_PRIMARYATTACK_2,
	ACT_SECONDARY_VM_RELOAD_2,

	ACT_MELEE_VM_DRAW,
	ACT_MELEE_VM_HOLSTER,
	ACT_MELEE_VM_IDLE,
	ACT_MELEE_VM_PULLBACK,
	ACT_MELEE_VM_PRIMARYATTACK,
	ACT_MELEE_VM_SECONDARYATTACK,
	ACT_MELEE_VM_RELOAD,			
	ACT_MELEE_VM_DRYFIRE,		
	ACT_MELEE_VM_IDLE_TO_LOWERED,
	ACT_MELEE_VM_IDLE_LOWERED,
	ACT_MELEE_VM_LOWERED_TO_IDLE,
	ACT_MELEE_VM_STUN,
	ACT_MELEE_VM_HITCENTER,		
	ACT_MELEE_VM_SWINGHARD,

	ACT_PDA_VM_DRAW,
	ACT_PDA_VM_HOLSTER,
	ACT_PDA_VM_IDLE,
	ACT_PDA_VM_PULLBACK,
	ACT_PDA_VM_PRIMARYATTACK,
	ACT_PDA_VM_SECONDARYATTACK,
	ACT_PDA_VM_RELOAD,			
	ACT_PDA_VM_DRYFIRE,		
	ACT_PDA_VM_IDLE_TO_LOWERED,
	ACT_PDA_VM_IDLE_LOWERED,
	ACT_PDA_VM_LOWERED_TO_IDLE,

	ACT_ENGINEER_PDA1_VM_DRAW,
	ACT_ENGINEER_PDA2_VM_DRAW,
	ACT_ENGINEER_BLD_VM_DRAW,
	ACT_ENGINEER_PDA1_VM_IDLE,
	ACT_ENGINEER_PDA2_VM_IDLE,
	ACT_ENGINEER_BLD_VM_IDLE,

	ACT_ITEM1_VM_DRAW,
	ACT_ITEM1_VM_HOLSTER,
	ACT_ITEM1_VM_IDLE,
	ACT_ITEM1_VM_IDLE_2,
	ACT_ITEM1_VM_PULLBACK,
	ACT_ITEM1_VM_PRIMARYATTACK,
	ACT_ITEM1_VM_SECONDARYATTACK,
	ACT_ITEM1_VM_RELOAD,			
	ACT_ITEM1_VM_DRYFIRE,		
	ACT_ITEM1_VM_IDLE_TO_LOWERED,
	ACT_ITEM1_VM_IDLE_LOWERED,
	ACT_ITEM1_VM_LOWERED_TO_IDLE,
	ACT_ITEM1_RELOAD_START,			
	ACT_ITEM1_RELOAD_FINISH,			
	ACT_ITEM1_VM_HITCENTER,
	ACT_ITEM1_VM_SWINGHARD,
	ACT_ITEM1_BACKSTAB_VM_UP,
	ACT_ITEM1_BACKSTAB_VM_DOWN,
	ACT_ITEM1_BACKSTAB_VM_IDLE,
	ACT_MELEE_VM_ITEM1_STUN,

	ACT_ITEM2_VM_DRAW,
	ACT_ITEM2_VM_HOLSTER,
	ACT_ITEM2_VM_IDLE,
	ACT_ITEM2_VM_PULLBACK,
	ACT_ITEM2_VM_PRIMARYATTACK,
	ACT_ITEM2_VM_SECONDARYATTACK,
	ACT_ITEM2_VM_RELOAD,			
	ACT_ITEM2_VM_DRYFIRE,		
	ACT_ITEM2_VM_IDLE_TO_LOWERED,
	ACT_ITEM2_VM_IDLE_LOWERED,
	ACT_ITEM2_VM_LOWERED_TO_IDLE,
	ACT_ITEM2_VM_CHARGE,
	ACT_ITEM2_VM_IDLE_2,
	ACT_ITEM2_VM_IDLE_3,
	ACT_ITEM2_VM_CHARGE_IDLE_3,
	ACT_ITEM2_VM_HITCENTER,
	ACT_ITEM2_VM_SWINGHARD,
	ACT_ITEM2_BACKSTAB_VM_UP,
	ACT_ITEM2_BACKSTAB_VM_DOWN,
	ACT_ITEM2_BACKSTAB_VM_IDLE,
	ACT_MELEE_VM_ITEM2_STUN,

	ACT_ITEM3_VM_DRAW,
	ACT_ITEM3_VM_HOLSTER,
	ACT_ITEM3_VM_IDLE,
	ACT_ITEM3_VM_PULLBACK,
	ACT_ITEM3_VM_PRIMARYATTACK,
	ACT_ITEM3_VM_SECONDARYATTACK,
	ACT_ITEM3_VM_RELOAD,			
	ACT_ITEM3_VM_DRYFIRE,		
	ACT_ITEM3_VM_IDLE_TO_LOWERED,
	ACT_ITEM3_VM_IDLE_LOWERED,
	ACT_ITEM3_VM_LOWERED_TO_IDLE,
	ACT_ITEM3_VM_CHARGE,
	ACT_ITEM3_VM_IDLE_2,
	ACT_ITEM3_VM_IDLE_3,
	ACT_ITEM3_VM_CHARGE_IDLE_3,
	ACT_ITEM3_VM_HITCENTER,
	ACT_ITEM3_VM_SWINGHARD,

	ACT_SECONDARY2_VM_DRAW,
	ACT_SECONDARY2_VM_HOLSTER,
	ACT_SECONDARY2_VM_IDLE,
	ACT_SECONDARY2_VM_PULLBACK,
	ACT_SECONDARY2_VM_PRIMARYATTACK,
	ACT_SECONDARY2_VM_SECONDARY2ATTACK,
	ACT_SECONDARY2_VM_RELOAD,			
	ACT_SECONDARY2_RELOAD_START,
	ACT_SECONDARY2_RELOAD_FINISH,
	ACT_SECONDARY2_VM_RELOAD2,			
	ACT_SECONDARY2_VM_DRYFIRE,		
	ACT_SECONDARY2_VM_IDLE_TO_LOWERED,
	ACT_SECONDARY2_VM_IDLE_LOWERED,
	ACT_SECONDARY2_VM_LOWERED_TO_IDLE,
	
	ACT_BACKSTAB_VM_UP,
	ACT_BACKSTAB_VM_DOWN,
	ACT_BACKSTAB_VM_IDLE,

	ACT_PRIMARY_ATTACK_STAND_PREFIRE,
	ACT_PRIMARY_ATTACK_STAND_POSTFIRE,
	ACT_PRIMARY_ATTACK_STAND_STARTFIRE,
	ACT_PRIMARY_ATTACK_CROUCH_PREFIRE,
	ACT_PRIMARY_ATTACK_CROUCH_POSTFIRE,
	ACT_PRIMARY_ATTACK_SWIM_PREFIRE,
	ACT_PRIMARY_ATTACK_SWIM_POSTFIRE,

	ACT_SECONDARY_ATTACK_STAND_PREFIRE,
	ACT_SECONDARY_ATTACK_STAND_POSTFIRE,
	ACT_SECONDARY_ATTACK_STAND_STARTFIRE,
	ACT_SECONDARY_ATTACK_CROUCH_PREFIRE,
	ACT_SECONDARY_ATTACK_CROUCH_POSTFIRE,
	ACT_SECONDARY_ATTACK_SWIM_PREFIRE,
	ACT_SECONDARY_ATTACK_SWIM_POSTFIRE,

	ACT_MELEE_ATTACK_STAND_PREFIRE,
	ACT_MELEE_ATTACK_STAND_POSTFIRE,
	ACT_MELEE_ATTACK_STAND_STARTFIRE,
	ACT_MELEE_ATTACK_CROUCH_PREFIRE,
	ACT_MELEE_ATTACK_CROUCH_POSTFIRE,
	ACT_MELEE_ATTACK_SWIM_PREFIRE,
	ACT_MELEE_ATTACK_SWIM_POSTFIRE,

	ACT_ITEM1_ATTACK_STAND_PREFIRE,
	ACT_ITEM1_ATTACK_STAND_POSTFIRE,
	ACT_ITEM1_ATTACK_STAND_STARTFIRE,
	ACT_ITEM1_ATTACK_CROUCH_PREFIRE,
	ACT_ITEM1_ATTACK_CROUCH_POSTFIRE,
	ACT_ITEM1_ATTACK_SWIM_PREFIRE,
	ACT_ITEM1_ATTACK_SWIM_POSTFIRE,

	ACT_ITEM2_ATTACK_STAND_PREFIRE,
	ACT_ITEM2_ATTACK_STAND_POSTFIRE,
	ACT_ITEM2_ATTACK_STAND_STARTFIRE,
	ACT_ITEM2_ATTACK_CROUCH_PREFIRE,
	ACT_ITEM2_ATTACK_CROUCH_POSTFIRE,
	ACT_ITEM2_ATTACK_SWIM_PREFIRE,
	ACT_ITEM2_ATTACK_SWIM_POSTFIRE,

	ACT_MP_STAND_MELEE_ALLCLASS,
	ACT_MP_CROUCH_MELEE_ALLCLASS,
	ACT_MP_RUN_MELEE_ALLCLASS,
	ACT_MP_WALK_MELEE_ALLCLASS,
	ACT_MP_AIRWALK_MELEE_ALLCLASS,
	ACT_MP_CROUCHWALK_MELEE_ALLCLASS,
	ACT_MP_JUMP_MELEE_ALLCLASS,
	ACT_MP_JUMP_START_MELEE_ALLCLASS,
	ACT_MP_JUMP_FLOAT_MELEE_ALLCLASS,
	ACT_MP_JUMP_LAND_MELEE_ALLCLASS,
	ACT_MP_SWIM_MELEE_ALLCLASS,

	ACT_MP_ATTACK_STAND_MELEE_ALLCLASS,		// RUN, WALK
	ACT_MP_ATTACK_STAND_MELEE_SECONDARY_ALLCLASS,
	ACT_MP_ATTACK_CROUCH_MELEE_ALLCLASS,		// CROUCHWALK
	ACT_MP_ATTACK_CROUCH_MELEE_SECONDARY_ALLCLASS,
	ACT_MP_ATTACK_SWIM_MELEE_ALLCLASS,
	ACT_MP_ATTACK_AIRWALK_MELEE_ALLCLASS,

	ACT_MELEE_ALLCLASS_VM_DRAW,
	ACT_MELEE_ALLCLASS_VM_HOLSTER,
	ACT_MELEE_ALLCLASS_VM_IDLE,
	ACT_MELEE_ALLCLASS_VM_PULLBACK,
	ACT_MELEE_ALLCLASS_VM_PRIMARYATTACK,
	ACT_MELEE_ALLCLASS_VM_SECONDARYATTACK,
	ACT_MELEE_ALLCLASS_VM_RELOAD,			
	ACT_MELEE_ALLCLASS_VM_DRYFIRE,		
	ACT_MELEE_ALLCLASS_VM_IDLE_TO_LOWERED,
	ACT_MELEE_ALLCLASS_VM_IDLE_LOWERED,
	ACT_MELEE_ALLCLASS_VM_LOWERED_TO_IDLE,
	ACT_MELEE_ALLCLASS_VM_STUN,
	ACT_MELEE_ALLCLASS_VM_HITCENTER,		
	ACT_MELEE_ALLCLASS_VM_SWINGHARD,

	// BOMB activities for TD mode.
	ACT_MP_STAND_BOMB,
	ACT_MP_JUMP_START_BOMB,
	ACT_MP_JUMP_FLOAT_BOMB,
	ACT_MP_JUMP_LAND_BOMB,
	ACT_MP_RUN_BOMB,
	ACT_MP_SWIM_BOMB,

	// More Primary VM activities for Soldier Quake RL
	ACT_VM_DRAW_QRL,
	ACT_VM_IDLE_QRL,
	ACT_VM_PULLBACK_QRL,
	ACT_VM_PRIMARYATTACK_QRL,
	ACT_VM_RELOAD_QRL,
	ACT_VM_RELOAD_START_QRL,			
	ACT_VM_RELOAD_FINISH_QRL,	

	// Third person anims for the Soldier Quake RL
	ACT_MP_RELOAD_STAND_PRIMARY3,
	ACT_MP_RELOAD_CROUCH_PRIMARY3,
	ACT_MP_RELOAD_AIRWALK_PRIMARY3,
	ACT_MP_RELOAD_STAND_PRIMARY3_LOOP,
	ACT_MP_RELOAD_CROUCH_PRIMARY3_LOOP,
	ACT_MP_RELOAD_AIRWALK_PRIMARY3_LOOP,
	ACT_MP_RELOAD_STAND_PRIMARY3_END,
	ACT_MP_RELOAD_CROUCH_PRIMARY3_END,
	ACT_MP_RELOAD_AIRWALK_PRIMARY3_END,
	ACT_MP_RELOAD_SWIM_PRIMARY3,

	// Throwable Animations
	ACT_MP_THROW,
	ACT_THROWABLE_VM_DRAW,
	ACT_THROWABLE_VM_IDLE,
	ACT_THROWABLE_VM_FIRE,

	// Spell Animations
	ACT_SPELL_VM_DRAW,
	ACT_SPELL_VM_IDLE, 
	ACT_SPELL_VM_ARM, 
	ACT_SPELL_VM_FIRE,

	// Bread Monster Sapper
	ACT_BREADSAPPER_VM_DRAW,
	ACT_BREADSAPPER_VM_IDLE,

	// Bread Gloves
	ACT_BREADGLOVES_VM_HITLEFT,
	ACT_BREADGLOVES_VM_HITRIGHT,
	ACT_BREADGLOVES_VM_SWINGHARD,
	ACT_BREADGLOVES_VM_IDLE,
	ACT_BREADGLOVES_VM_DRAW,

	ACT_BREADMONSTER_GLOVES_IDLE,
	ACT_BREADMONSTER_GLOVES_HITRIGHT,
	ACT_BREADMONSTER_GLOVES_HITUP,

	ACT_BREADMONSTER_VM_DRAW,
	ACT_BREADMONSTER_VM_IDLE,
	ACT_BREADMONSTER_VM_PRIMARYATTACK,

	ACT_PARACHUTE_DEPLOY,
	ACT_PARACHUTE_DEPLOY_IDLE,
	ACT_PARACHUTE_RETRACT,
	ACT_PARACHUTE_RETRACT_IDLE,

	ACT_BOT_SPAWN,
	ACT_BOT_PANIC,
	ACT_BOT_PRIMARY_MOVEMENT,
	ACT_BOT_GESTURE_FLINCH,
	ACT_BOT_PANIC_START,
	ACT_BOT_PANIC_END,

	ACT_ENGINEER_REVOLVER_DRAW,
	ACT_ENGINEER_REVOLVER_IDLE,
	ACT_ENGINEER_REVOLVER_PRIMARYATTACK,
	ACT_ENGINEER_REVOLVER_RELOAD,

	// Kart!
	ACT_KART_IDLE,
	ACT_KART_ACTION_SHOOT,
	ACT_KART_ACTION_DASH,
	ACT_KART_JUMP_START,
	ACT_KART_JUMP_FLOAT,
	ACT_KART_JUMP_LAND,
	ACT_KART_IMPACT,
	ACT_KART_IMPACT_BIG,
	ACT_KART_GESTURE_POSITIVE,
	ACT_KART_GESTURE_NEGATIVE,

	// grappling hook
	ACT_GRAPPLE_DRAW,
	ACT_GRAPPLE_IDLE,
	ACT_GRAPPLE_FIRE_START,
	ACT_GRAPPLE_FIRE_IDLE,
	ACT_GRAPPLE_PULL_START,
	ACT_GRAPPLE_PULL_IDLE,
	ACT_GRAPPLE_PULL_END,

	// inspect
	ACT_PRIMARY_VM_INSPECT_START,
	ACT_PRIMARY_VM_INSPECT_IDLE,
	ACT_PRIMARY_VM_INSPECT_END,

	ACT_SECONDARY_VM_INSPECT_START,
	ACT_SECONDARY_VM_INSPECT_IDLE,
	ACT_SECONDARY_VM_INSPECT_END,

	ACT_MELEE_VM_INSPECT_START,
	ACT_MELEE_VM_INSPECT_IDLE,
	ACT_MELEE_VM_INSPECT_END,

	// this is the end of the global activities, private per-monster activities start here.
	LAST_SHARED_ACTIVITY,
};

#define MAX_NPCS		200

#define	DAMAGE_NO				0
#define DAMAGE_EVENTS_ONLY		1
#define	DAMAGE_YES				2
#define	DAMAGE_AIM				3

enum NextBotDebugType
{
	DEBUG_NONE = 0x0000,
	DEBUG_ANY  = 0xffff,

	DEBUG_BEHAVIOR   = (1 << 0), // NextBotBehavior
	DEBUG_LOOK_AT    = (1 << 1), // NextBotBodyInterface
	DEBUG_PATH       = (1 << 2), // NextBotPath, NextBotPathFollow, NextBotChasePath
	DEBUG_ANIMATION  = (1 << 3),
	DEBUG_LOCOMOTION = (1 << 4), // NextBotLocomotionInterface
	DEBUG_VISION     = (1 << 5), // NextBotVisionInterface
	DEBUG_HEARING    = (1 << 6),
	DEBUG_EVENTS     = (1 << 7), // NextBotEventResponderInterface
	DEBUG_ERRORS     = (1 << 8),
};

const CBaseNPC INVALID_NPC = view_as<CBaseNPC>(-1);
const CNavArea NULL_AREA = view_as<CNavArea>(0);
const CNavLadder NULL_LADDER_AREA = view_as<CNavLadder>(0);
const CKnownEntity NULL_KNOWN_ENTITY = view_as<CKnownEntity>(0);
const NextBotAction NULL_ACTION = view_as<NextBotAction>(0);

native INextBot CBaseNPC_GetNextBotOfEntity(int iEntity);
native void CBaseNPC_HookEventKilled(int iEntity);

enum
{
	NAV_MESH_CROUCH = 0x0001, 
	NAV_MESH_JUMP = 0x0002, 
	NAV_MESH_PRECISE = 0x0004, 
	NAV_MESH_NO_JUMP = 0x0008, 
	NAV_MESH_STOP = 0x0010, 
	NAV_MESH_RUN = 0x0020, 
	NAV_MESH_WALK = 0x0040, 
	NAV_MESH_AVOID = 0x0080, 
	NAV_MESH_TRANSIENT = 0x0100, 
	NAV_MESH_DONT_HIDE = 0x0200, 
	NAV_MESH_STAND = 0x0400, 
	NAV_MESH_NO_HOSTAGES = 0x0800
};

enum NavDirType
{
	NORTH = 0,
	EAST = 1,
	SOUTH = 2,
	WEST = 3,

	NUM_DIRECTIONS
};

enum NavTraverseType
{
	// NOTE: First 4 directions MUST match NavDirType
	GO_NORTH = 0,
	GO_EAST,
	GO_SOUTH,
	GO_WEST,

	GO_LADDER_UP,
	GO_LADDER_DOWN,
	GO_JUMP,
	GO_ELEVATOR_UP,
	GO_ELEVATOR_DOWN,

	NUM_TRAVERSE_TYPES
};

//Thanks to Pelipoika & Sigsegv
enum TFNavAttributeType
{
	BLOCKED                     = (1 << 0),
	RED_SPAWN_ROOM              = (1 << 1),
	BLUE_SPAWN_ROOM             = (1 << 2),
	SPAWN_ROOM_EXIT             = (1 << 3),
	AMMO                        = (1 << 4),
	HEALTH                      = (1 << 5),
	CONTROL_POINT               = (1 << 6),
	BLUE_SENTRY                 = (1 << 7),
	RED_SENTRY                  = (1 << 8),
	/* bit  9: unused */
	/* bit 10: unused */
	BLUE_SETUP_GATE             = (1 << 11),
	RED_SETUP_GATE              = (1 << 12),
	BLOCKED_AFTER_POINT_CAPTURE = (1 << 13),
	BLOCKED_UNTIL_POINT_CAPTURE = (1 << 14),
	BLUE_ONE_WAY_DOOR           = (1 << 15),
	RED_ONE_WAY_DOOR            = (1 << 16),
	WITH_SECOND_POINT           = (1 << 17),
	WITH_THIRD_POINT            = (1 << 18),
	WITH_FOURTH_POINT           = (1 << 19),
	WITH_FIFTH_POINT            = (1 << 20),
	SNIPER_SPOT                 = (1 << 21),
	SENTRY_SPOT                 = (1 << 22),
	/* bit 23: unused */
	/* bit 24: unused */
	NO_SPAWNING                 = (1 << 25),
	RESCUE_CLOSET               = (1 << 26),
	BOMB_DROP                   = (1 << 27),
	DOOR_NEVER_BLOCKS           = (1 << 28),
	DOOR_ALWAYS_BLOCKS          = (1 << 29),
	UNBLOCKABLE                 = (1 << 30),
	/* bit 31: unused */
};

methodmap SurroundingAreasCollector < Handle
{
	public native CNavArea Get(int index);
	public native int Count();
};

methodmap TSurroundingAreasCollector < Handle
{
	public native CTNavArea Get(int index);
	public native int Count();
};

typeset CollectSurroundingAreasCallback
{
	function void (TSurroundingAreasCollector collector, any data);
};

methodmap CNavMesh
{
	public native SurroundingAreasCollector CollectSurroundingAreas(CNavArea startArea, float travelDistanceLimit = 1500.0, float maxStepUpLimit = 18.0, float maxDropDownLimit = 100.0);
	public native void TCollectSurroundingAreas(CNavArea startArea, float travelDistanceLimit = 1500.0, float maxStepUpLimit = 18.0, float maxDropDownLimit = 100.0, CollectSurroundingAreasCallback callback, any data = 0);
	public native CNavArea GetNearestNavArea(const float pos[3], bool anyZ = false, float maxDist = 10000.0, bool checkLOS = false, bool checkGround = true, int team = -2);
};

CNavMesh TheNavMesh;

methodmap CTNavArea
{
	public native NavTraverseType GetParentHow();
	public native float GetCostSoFar();
	public native CNavArea GetRealNavArea();
};

methodmap CNavArea
{
	public native void UpdateBlocked(bool force = false, int teamID = -2);
	public native bool IsBlocked(int teamID, bool ignoreNavBlockers = false);

	public native int GetID();
	
	public native void SetParent(CNavArea parent, NavTraverseType how = NUM_TRAVERSE_TYPES);
	public native CNavArea GetParent();
	public native NavTraverseType GetParentHow();
	
	public native void SetCostSoFar(float value);
	public native float GetCostSoFar();
	
	public native int GetAttributes();
	public bool HasAttributes(int bits) { return ( this.GetAttributes() & bits ) ? true : false; }
	public native void GetCenter(float vecCenter[3]);
	
	public native bool IsConnected(const CNavArea area, NavDirType dir);
	public native bool IsEdge(NavDirType dir);
	
	public native bool Contains(const CNavArea area);
	public native float GetZ(float x, float y);
	public native float GetZVector(float vecPos[3]);
	public native void ComputeNormal(float vecNormal[3], bool alternate = false);
};

methodmap CNavLadder
{
	property float length
	{
		public native get();
	}
};

methodmap INextBotEventResponder
{
	public native INextBotEventResponder FirstContainedResponder();
	public native INextBotEventResponder NextContainedResponder(INextBotEventResponder prev);
};

methodmap INextBot < INextBotEventResponder
{
	public native void Reset();
	public native void Update();
	public native void Upkeep();

	public native bool IsRemovedOnReset();

	public native int GetEntity();
	public native int GetNextBotCombatCharacter();

	public native ILocomotion GetLocomotionInterface();
	public native IBody GetBodyInterface();
	public native IIntention GetIntentionInterface();
	public native IVision GetVisionInterface();

	public native bool SetPosition(const float pos[3]);
	public native void GetPosition(float pos[3]);

	public native bool IsEnemy(int entity);
	public native bool IsFriend(int entity);
	public native bool IsSelf(int entity);

	public native bool IsAbleToClimbOnto(int entity);
	public native bool IsAbleToBreak(int entity);
	public native bool IsAbleToBlockMovementOf(INextBot bot);

	public native bool ShouldTouch(int entity);

	public native void ReactToSurvivorVisibility();
	public native void ReactToSurvivorNoise();
	public native void ReactToSurvivorContact();

	public native bool IsImmobile();
	public native float GetImmobileDuration();
	public native void ClearImmobileStatus();
	public native float GetImmobileSpeedThreshold();

	public native PathFollower GetCurrentPath();
	public native void SetCurrentPath(const PathFollower path);
	public native void NotifyPathDestruction(const PathFollower path);

	public native bool IsRangeLessThan(int entity, float dist);
	public native bool IsRangeLessThanEx(const float pos[3], float dist);
	public native bool IsRangeGreaterThan(int entity, float dist);
	public native bool IsRangeGreaterThanEx(const float pos[3], float dist);

	public native float GetRangeTo(int entity);
	public native float GetRangeToEx(const float pos[3]);
	public native float GetRangeSquaredTo(int entity);
	public native float GetRangeSquaredToEx(const float pos[3]);

	public native bool IsDebugging(NextBotDebugType type);
	public native void GetDebugIdentifier(char[] name, int maxsize);
	public native bool IsDebugFilterMatch(const char[] name);
	public native void DisplayDebugText(const char[] name);
};

methodmap INextBotComponent < INextBotEventResponder
{
	public native void Reset();
	public native void Update();
	public native void Upkeep();

	public native INextBot GetBot();
};

enum FieldOfViewCheckType
{
	USE_FOV,
	DISREGARD_FOV
};

methodmap CKnownEntity
{
	public native void Destroy();
	public native void UpdatePosition();
	public native int GetEntity();
	public native void GetLastKnownPosition(float vecPos[3]);
	public native bool HasLastKnownPositionBeenSeen();
	public native void MarkLastKnownPositionAsSeen();
	public native CNavArea GetLastKnownArea();
	public native float GetTimeSinceLastKnown();
	public native float GetTimeSinceBecameKnown();
	public native void UpdateVisibilityStatus(bool visible);
	public native bool IsVisibleInFOVNow();
	public native bool IsVisibleRecently();
	public native float GetTimeSinceBecameVisible();
	public native float GetTimeWhenBecameVisible();
	public native float GetTimeSinceLastSeen();
	public native bool WasEverVisible();
	public native bool IsObsolete();
	public native bool Is(int iEntity);
}

methodmap IVision < INextBotComponent
{
	public native CKnownEntity GetPrimaryKnownThreat(bool bVisible);
	public native float GetTimeSinceVisible(int iTeam);
	public native CKnownEntity GetClosestKnown(int iTeam);
	public native int GetKnownCount(int team, bool onlyVisible = false, float rangeLimit = -1.0);
	public native CKnownEntity GetKnown(int iEntity);
	public native void AddKnownEntity(int iEntity);
	public native void ForgetEntity(int iEntity);
	public native void ForgetAllKnownEntities();
	public native float GetMaxVisionRange();
	public native float GetMinRecognizeTime();
	public native bool IsAbleToSeeTarget(int iEntity, FieldOfViewCheckType checkFOV, float vecPos[3] = NULL_VECTOR);
	public native bool IsAbleToSee(float vecPos[3], FieldOfViewCheckType checkFOV);
	public native bool IsIgnored(int iEntity);
	public native bool IsVisibleEntityNoticed(int iEntity);
	public native bool IsInFieldOfView(float vecPos[3]);
	public native bool IsInFieldOfViewTarget(int iEntity);
	public native float GetDefaultFieldOfView();
	public native float GetFieldOfView();
	public native void SetFieldOfView(float horizAngle);
	public native bool IsLineOfSightClear(float vecPos[3]);
	public native bool IsLineOfSightClearToEntity(int iActor, float vecPos[3]=NULL_VECTOR);
	public native bool IsLookingAt(float vecPos[3], float cosTolerance = 0.95);
	public native bool IsLookingAtTarget(int iActor, float cosTolerance = 0.95);
};

methodmap IIntention < INextBotComponent
{
	public native void Reset();
	public native void Update();
	public native bool ShouldPickUp( int item );
	public native bool ShouldHurry();
	public native bool ShouldRetreat();
	public native bool ShouldAttack( int them );
	public native bool IsHindrance( int blocker );
	public native void SelectTargetPoint( int subject, float buffer[3] );
	public native bool IsPositionAllowed( const float pos[3] );
	public native CKnownEntity SelectMoreDangerousThreat( int subject, CKnownEntity threat1, CKnownEntity threat2 );
}

enum TraverseWhenType 
{ 
	IMMEDIATELY,
	EVENTUALLY
};

methodmap ILocomotion < INextBotComponent
{
	public native void Approach(const float dst[3], float unknown);
	public native void DriveTo(const float dst[3]);

	public native bool ClimbUpToLedge(const float dst[3], const float dir[3], int entity);
	public native void JumpAcrossGap(const float dst[3], const float dir[3]);
	public native void Jump();
	public native bool IsClimbingOrJumping();
	public native bool IsClimbingUpToLedge();
	public native bool IsJumpingAcrossGap();
	public native bool IsScrambling();

	public native void Run();
	public native void Walk();
	public native void Stop();

	public native bool IsRunning();

	public native void SetDesiredSpeed(float speed);
	public native float GetDesiredSpeed();

	public native void SetSpeedLimit(float limit);
	public native float GetSpeedLimit();

	public native bool IsOnGround();
	public native int GetGround();
	public native void GetGroundNormal(float normal[3]);
	public native float GetGroundSpeed();
	public native void GetGroundMotionVector(float motion[3]);

	public native void ClimbLadder(CNavLadder ladder, CNavArea area);
	public native void DescendLadder(CNavLadder ladder, CNavArea area);

	public native bool IsUsingLadder();
	public native bool IsAscendingOrDescendingLadder();
	public native bool IsAbleToAutoCenterOnLadder();

	public native void FaceTowards(const float pos[3]);

	public native void SetDesiredLean(const float lean[3]);
	public native void GetDesiredLean(float lean[3]);

	public native bool IsAbleToJumpAcrossGaps();
	public native bool IsAbleToClimb();

	public native void GetFeet(float feet[3]);

	public native float GetStepHeight();
	public native float GetMaxJumpHeight();
	public native float GetDeathDropHeight();
	public native float GetRunSpeed();
	public native float GetWalkSpeed();

	public native float GetMaxAcceleration();
	public native float GetMaxDeceleration();

	public native void GetVelocity(float vel[3]);

	public native float GetSpeed();

	public native void GetMotionVector(float motion[3]);

	public native bool IsAreaTraversable(CNavArea area);
	public native float GetTraversableSlopeLimit();

	public native bool IsPotentiallyTraversable(const float from[3], const float to[3], TraverseWhenType when);
	public native bool HasPotentialGap(const float from[3], const float to[3]);
	public native bool IsGap(const float from[3], const float to[3]);
	public native bool IsEntityTraversable(int entity, TraverseWhenType when);

	public native bool IsStuck();
	public native float GetStuckDuration();
	public native void ClearStuckStatus(const char[] reason);

	public native bool IsAttemptingToMove();

	public native bool ShouldCollideWith(int entity);

	public native void AdjustPosture(const float lean[3]);
	public native void StuckMonitor();
};

methodmap NextBotGroundLocomotion < ILocomotion
{
	public native void GetAcceleration(float acel[3]);
	public native void SetAcceleration(const float acel[3]);
	public native void SetVelocity(const float vel[3]);
	public native float GetGravity();
	public native float GetFrictionForward();
	public native float GetFrictionSideways();
	public native float GetMaxYawRate();
}

typeset NavPathCostFunctor
{
	function float(INextBot bot, CNavArea area, CNavArea fromArea, CNavLadder ladder, int iElevator, float length);
};
typedef TraceFilterActors = function bool(int iEntityCollide, int contentsMask, int desiredcollisiongroup);

enum SegmentType
{
	ON_GROUND,
	DROP_DOWN,
	CLIMB_UP,
	JUMP_OVER_GAP,
	LADDER_UP,
	LADDER_DOWN,
	
	NUM_SEGMENT_TYPES
};

enum MoveCursorType
{
	MOVECUR_ABS = 0,
	MOVECUR_REL = 1,
	MOVECUR_MAX,
};

enum MoveToFailureType
{
	FAIL_NO_PATH_EXISTS = 0,
	FAIL_STUCK        = 1,
	FAIL_FELL_OFF     = 2,
};

methodmap Segment
{
	public native void GetPos(float pos[3]);
};

methodmap CursorData
{
};

typeset PathComputeCallback
{
	function void (Path path, bool bSuccess, any data);
};

methodmap Path
{
	public native Path(NavPathCostFunctor costfunction = INVALID_FUNCTION, TraceFilterActors ignoreActorsFilter, TraceFilterActors onlyActorsFilter);
	public native float GetLength();
	public native void GetPosition(float dist, Segment seg, float pos[3]);
	public native void GetStartPosition(float pos[3]);
	public native void GetEndPosition(float pos[3]);
	public native int GetSubject();
	public native Segment GetCurrentGoal();
	public native float GetAge();
	public native void MoveCursorToStart();
	public native void MoveCursorToEnd();
	public native void MoveCursor(float dist, MoveCursorType mctype);
	public native float GetCursorPosition();
	public native CursorData GetCursorData();
	public native bool IsValid();
	public native void Invalidate();
	public native void Draw(Segment seg);
	public native void DrawInterpolated(float from, float to);
	public native Segment FirstSegment();
	public native Segment NextSegment(Segment seg);
	public native Segment PriorSegment(Segment seg);
	public native Segment LastSegment();
	public native bool ComputeToPos(INextBot bot, float vecPos[3], float maxPathLength = 0.0, bool includeGoalIfPathFails = true);
	public native bool ComputeToTarget(INextBot bot, int entity, float maxPathLength = 0.0, bool includeGoalIfPathFails = true);
	public native void Destroy();
	
	// Threaded
	public native bool ComputeToPosT(INextBot bot, float vecPos[3], float maxPathLength = 0.0, bool includeGoalIfPathFails = true, PathComputeCallback callback, any data = 0);
	public native bool ComputeToTargetT(INextBot bot, int entity, float maxPathLength = 0.0, bool includeGoalIfPathFails = true, PathComputeCallback callback, any data = 0);
};

methodmap PathFollower < Path
{
	public native PathFollower(NavPathCostFunctor costfunction = INVALID_FUNCTION, TraceFilterActors ignoreActorsFilter, TraceFilterActors onlyActorsFilter);
	public native void Update(INextBot nextbot);
	public native void SetMinLookAheadDistance(float dist);
	public native int GetHindrance();
	public native bool IsDiscontinuityAhead(INextBot nextbot, SegmentType stype, float max_dist);
	public native void Destroy();
};

enum SubjectChaseType
{
	LEAD_SUBJECT,
	DONT_LEAD_SUBJECT
};

methodmap ChasePath < PathFollower
{
	public native ChasePath(SubjectChaseType how = DONT_LEAD_SUBJECT, NavPathCostFunctor costfunction = INVALID_FUNCTION, TraceFilterActors ignoreActorsFilter, TraceFilterActors onlyActorsFilter);
	public native void Update(INextBot bot, int iTarget, float vecPredictedPos[3]=NULL_VECTOR);
	public native float GetLeadRadius();
	public native float GetMaxPathLength();
	public native void PredictSubjectPosition(INextBot nextbot, int entity, float pos[3]);
	public native bool IsRepathNeeded(INextBot nextbot, int entity);
	public native float GetLifetime();
	public native void Destroy();
};

methodmap DirectChasePath < ChasePath
{
	public native DirectChasePath(SubjectChaseType how = DONT_LEAD_SUBJECT, NavPathCostFunctor costfunction = INVALID_FUNCTION, TraceFilterActors ignoreActorsFilter, TraceFilterActors onlyActorsFilter);
	public native void Destroy();
};

enum LookAtPriorityType
{
	BORING,
	INTERESTING,				
	IMPORTANT,					
	CRITICAL,			
	MANDATORY
};

enum ActivityType 
{ 
	MOTION_CONTROLLED_XY	= 0x0001,
	MOTION_CONTROLLED_Z		= 0x0002,
	ACTIVITY_UNINTERRUPTIBLE= 0x0004,
	ACTIVITY_TRANSITORY		= 0x0008,
	ENTINDEX_PLAYBACK_RATE	= 0x0010,
};
	
enum PostureType
{
	STAND,
	CROUCH,
	SIT,
	CRAWL,
	LIE
};
	
enum ArousalType
{
	NEUTRAL,
	ALERT,
	INTENSE
};

methodmap IBody < INextBotComponent
{
	public native bool SetPosition(float pos[3]);

	public native void GetEyePosition(float eyepos[3]);
	public native void GetViewVector(float view[3]);

	//public native void AimHeadTowards(float pos[3], LookAtPriorityType priority, float duration, PluginBotReply reply, const char[] reason);
	//public native void AimHeadTowardsEx(int entity, LookAtPriorityType priority, float duration, PluginBotReply reply, const char[] reason);

	public native bool IsHeadAimingOnTarget();
	public native bool IsHeadSteady();
	public native float GetHeadSteadyDuration();
	public native float GetHeadAimSubjectLeadTime();
	public native float GetHeadAimTrackingInterval();
	public native void ClearPendingAimReply();
	public native float GetMaxHeadAngularVelocity();

	//public native bool StartActivity(Activity act, int unknown);
	//public native int SelectAnimationSequence(Activity act);
	//public native Activity GetActivity();
	//public native bool IsActivity(Activity act);
	//public native bool HasActivityType(int unknown);

	public native void SetDesiredPosture(PostureType posture);
	public native PostureType GetDesiredPosture();
	public native bool IsDesiredPosture(PostureType posture);
	public native bool IsInDesiredPosture();
	public native PostureType GetActualPosture();
	public native bool IsActualPosture(PostureType posture);
	public native bool IsPostureMobile();
	public native bool IsPostureChanging();

	public native void SetArousal(ArousalType arousal);
	public native ArousalType GetArousal();
	public native bool IsArousal(ArousalType arousal);

	public native float GetHullWidth();
	public native float GetHullHeight();
	public native float GetStandHullHeight();
	public native float GetCrouchHullHeight();
	public native void GetHullMins(float mins[3]);
	public native void GetHullMaxs(float maxs[3]);

	public native int GetSolidMask();
	public native int GetCollisionGroup();
};

methodmap CExtNPC __nullable__
{
	public native int GetEntity();
	property int Index
	{
		public get() { return view_as<int>(this); }
	}
};

methodmap CBaseNPC < CExtNPC
{
	public native CBaseNPC();
	
	// Interfaces
	public native INextBot GetBot();
	public native NextBotGroundLocomotion GetLocomotion();
	public native IBody GetBody();
	public native IVision GetVision();
	
	public native void SetType(char[] sBuffer);
	public native void GetType(char[] sBuffer, int length);
	
	// Body Functions
	public native void SetBodyMins(float vec[3]);
	public native void SetBodyMaxs(float vec[3]);
	public native void GetBodyMins(float vec[3]);
	public native void GetBodyMaxs(float vec[3]);
	
	property float flStepSize
	{
		public native get();
		public native set(float StepSize);
	}
	property float flGravity
	{
		public native get();
		public native set(float Gravity);
	}
	property float flAcceleration
	{
		public native get();
		public native set(float Acceleration);
	}
	property float flJumpHeight
	{
		public native get();
		public native set(float JumpHeight);
	}
	property float flDeathDropHeight
	{
		public native get();
		public native set(float DeathHeight);
	}
	property float flWalkSpeed
	{
		public native get();
		public native set(float WalkSpeed);
	}
	property float flRunSpeed
	{
		public native get();
		public native set(float RunSpeed);
	}
	property float flFrictionForward
	{
		public native get();
		public native set(float Friction);
	}
	property float flFrictionSideways
	{
		public native get();
		public native set(float Friction);
	}
	
	// =============================
	// DEPRECATED PLEASE DO NOT USE!
	// =============================
	
	property int iMaxHealth
	{
		#pragma deprecated Please use GetEntity() + GetEntProp() functions
		public get() { return GetEntProp(this.GetEntity(), Prop_Data, "m_iMaxHealth"); }
		#pragma deprecated Please use GetEntity() + SetEntProp() functions
		public set(int value) { SetEntProp(this.GetEntity(), Prop_Data, "m_iMaxHealth", value); }
	}
	property int iHealth
	{
		#pragma deprecated Please use GetEntity() + GetEntProp() functions
		public get() { return GetEntProp(this.GetEntity(), Prop_Data, "m_iHealth"); }
		#pragma deprecated Please use GetEntity() + SetEntProp() functions
		public set(int value) { SetEntProp(this.GetEntity(), Prop_Data, "m_iHealth", value); }
	}
	property int iTeamNum
	{
		#pragma deprecated Please use GetEntity() + GetEntProp() functions
		public get() { return GetEntProp(this.GetEntity(), Prop_Data, "m_iTeamNum"); }
		#pragma deprecated Please use GetEntity() + SetEntProp() functions
		public set(int iTeam) { SetEntProp(this.GetEntity(), Prop_Data, "m_iTeamNum", iTeam); }
	}
	property int nSkin
	{
		#pragma deprecated Please use GetEntity() + GetEntProp() functions
		public get() { return GetEntProp(this.GetEntity(), Prop_Data, "m_nSkin"); }
		#pragma deprecated Please use GetEntity() + SetEntProp() functions
		public set(int skin) { SetEntProp(this.GetEntity(), Prop_Data, "m_nSkin", skin); }
	}
	property int BloodColor
	{
		#pragma deprecated Please use GetEntity() + GetEntProp() functions
		public get() { return GetEntProp(this.GetEntity(), Prop_Data, "m_bloodColor"); }
		#pragma deprecated Please use GetEntity() + SetEntProp() functions
		public set(int iBloodColor) { SetEntProp(this.GetEntity(), Prop_Data, "m_bloodColor", iBloodColor); }
	}
	
	#pragma deprecated Use GetLocomotion() + Approach() instead
	public native void Approach(const float vecPos[3]);
	#pragma deprecated Use GetLocomotion() + FaceTowards() instead
	public native void FaceTowards(const float vecPos[3]);
	#pragma deprecated Use GetLocomotion() + Walk() instead
	public native void Walk();
	#pragma deprecated Use GetLocomotion() + Run() instead
	public native void Run();
	#pragma deprecated Use GetLocomotion() + Stop() instead
	public native void Stop();
	#pragma deprecated Use GetLocomotion() + Jump() instead
	public native void Jump();
	#pragma deprecated Use GetLocomotion() + IsOnGround() instead
	public native bool IsOnGround();
	#pragma deprecated Use GetLocomotion() + IsClimbingOrJumping() instead
	public native bool IsClimbingOrJumping();
	#pragma deprecated Use GetLocomotion() + SetVelocity() instead
	public native void SetVelocity(float vec[3]);
	#pragma deprecated Use GetLocomotion() + GetVelocity() instead
	public native void GetVelocity(float vec[3]);
	#pragma deprecated ResetPath never existed to begin with
	public native void ResetPath();
	
	#pragma deprecated Implement the hook yourself
	public void SetThinkFunction(SDKHookCB callback)
	{
		SDKHook(this.GetEntity(), SDKHook_Think, callback);
	}
	#pragma deprecated Implement the hook yourself
	public void SetOnTakeDamageFunction(SDKHookCB callback)
	{
		SDKHook(this.GetEntity(), SDKHook_OnTakeDamage, callback);
	}
	
	#pragma deprecated Pluse use CBaseEntity.GetVectors
	public native void GetVectors(float vecForward[3], float vecRight[3], float vecUp[3]);
	#pragma deprecated Please use sdktools functions
	public native void Teleport(float origin[3]=NULL_VECTOR, float angles[3]=NULL_VECTOR, float velocity[3]=NULL_VECTOR);
	#pragma deprecated Please use sdktools functions
	public native void Spawn();
	#pragma deprecated Please use sdktools functions
	public native void SetModel(const char[] model);
	#pragma deprecated Useless function
	public native void SetCollisionBounds(float vecMins[3], float vecMaxs[3]);
	#pragma deprecated Use GetEntity() + CBaseCombatCharacter.GetLastKnownArea() functions
	public native CNavArea GetLastKnownArea();
	
	#pragma deprecated Fully deprecated, please don't use this function or else your plugin won't load
	public native int EquipItem(const char[] attachment, const char[] model, const char[] anim = "", int skin = 0);
}

methodmap CNPCs __nullable__
{
	public native any FindNPCByEntIndex(int ent);
	public native bool IsValidNPC(any npc);
	//To-Do: add npcs relationships?
}

CNPCs TheNPCs;

// Gesture code

#define ANIM_LAYER_ACTIVE		0x0001
#define ANIM_LAYER_AUTOKILL		0x0002
#define ANIM_LAYER_KILLME		0x0004
#define ANIM_LAYER_DONTRESTORE	0x0008
#define ANIM_LAYER_CHECKACCESS	0x0010
#define ANIM_LAYER_DYING		0x0020

#define MAX_OVERLAYS			15

#define ANIM_LAYER_ACTIVE        0x0001 
#define ANIM_LAYER_AUTOKILL      0x0002 
#define ANIM_LAYER_KILLME        0x0004 
#define ANIM_LAYER_DONTRESTORE   0x0008 
#define ANIM_LAYER_CHECKACCESS   0x0010 
#define ANIM_LAYER_DYING         0x0020
#define ANIM_LAYER_NOEVENTS         0x0040

enum //CAnimationLayer 
{ 
    m_fFlags = 0,               //0x0000  
    m_bSequenceFinished = 4,    //0x0004  
    m_bLooping = 6,             //0x0006  
    m_nSequence = 8,            //0x0008  
    m_flCycle = 12,             //0x000C  
    m_flPrevCycle = 16,         //0x0010  
    m_flWeight = 20,            //0x0014  
    m_flPlaybackRate = 24,      //0x0018  
    m_flBlendIn = 28,           //0x001C  
    m_flBlendOut = 32,          //0x0020  
    m_flKillRate = 36,          //0x0024  
    m_flKillDelay = 40,         //0x0028  
    m_flLayerAnimtime = 44,     //0x002C  
    m_flLayerFadeOuttime = 48,  //0x0030  
    m_nActivity = 52,           //0x0034  
    m_nPriority = 56,           //0x0038  
    m_nOrder = 60,              //0x003C  
    m_flLastEventCheck = 64,    //0x0040  
    m_flLastEventAccess = 68,   //0x0044  
    m_pOwnerEntity = 72,        //0x0048  
     
    CAnimationLayer_Size = 76   //0x004C 
}; //Size=0x004C 

methodmap CAnimationOverlay  
{
	public CAnimationOverlay(Address address)
	{
		return view_as<CAnimationOverlay>(address);
	}
	
	property Address Address  
	{
		public get()  
		{
			return view_as<Address>(this); 
		}
	}
	
	property bool isNull
	{
		public get()  
		{
			return this.Address == Address_Null; 
		}
	}
	
	public any Get(int iOffset) 
	{ 
		return LoadFromAddress(this.Address + view_as<Address>(iOffset), NumberType_Int32); 
	}
	
	public void Set(int iOffset, any iValue) 
	{ 
		StoreToAddress(this.Address + view_as<Address>(iOffset), iValue, NumberType_Int32); 
	}
	
	public bool IsActive()    { return ((this.Get(m_fFlags) & ANIM_LAYER_ACTIVE)   != 0); } 
	public bool IsAutokill()  { return ((this.Get(m_fFlags) & ANIM_LAYER_AUTOKILL) != 0); } 
	public bool IsKillMe()    { return ((this.Get(m_fFlags) & ANIM_LAYER_KILLME)   != 0); } 
	public bool IsDying()     { return ((this.Get(m_fFlags) & ANIM_LAYER_DYING)    != 0); } 
	public bool NoEvents()    { return ((this.Get(m_fFlags) & ANIM_LAYER_NOEVENTS) != 0); }
	public void KillMe()      { int iFlags = this.Get(m_fFlags); this.Set(m_fFlags, (iFlags |= ANIM_LAYER_KILLME)); } 
	public void AutoKill()    { int iFlags = this.Get(m_fFlags); this.Set(m_fFlags, (iFlags |= ANIM_LAYER_AUTOKILL)); }
	public void Dying()       { int iFlags = this.Get(m_fFlags); this.Set(m_fFlags, (iFlags |= ANIM_LAYER_DYING));  } 
	public void Dead()        { int iFlags = this.Get(m_fFlags); this.Set(m_fFlags, (iFlags &= ~ANIM_LAYER_DYING)); }
	public bool IsAlive()         { int iFlags = this.Get(m_fFlags); return (((iFlags & ANIM_LAYER_ACTIVE) != 0) || ((iFlags & ANIM_LAYER_KILLME) == 0)); }
	public int GetLayerSequence() { return (this.Get(m_nSequence)); }
};

methodmap CBaseEntity
{
	public CBaseEntity(int iEnt) 
	{
		return view_as<CBaseEntity>(iEnt);
	}

	property int iEnt
	{
		public get() 
		{
			return view_as<int>(this);
		}
	}

	public static native int iUpdateOnRemove();
	
#if defined _dhooks_included
	public void Hook_UpdateOnRemove(DHookCallback callback)
	{
		static Handle hHook = null;
		if (hHook == null)
		{
			hHook = DHookCreate(CBaseEntity.iUpdateOnRemove(), HookType_Entity, ReturnType_Void, ThisPointer_CBaseEntity);
			if (hHook == null) return;
		}
		DHookEntity(hHook, false, this.iEnt, _, callback);
	}
#endif
	public native void Spawn();
	public native void SetModel(const char[] sModel);
	public native void Teleport(const float vecOrigin[3]=NULL_VECTOR, const float vecAngles[3]=NULL_VECTOR, const float vecVelocity[3]=NULL_VECTOR);
	public native void WorldSpaceCenter(float vecCenter[3]);
	public native void GetVectors(float vecForward[3], float vecRight[3], float vecUp[3]);
}

methodmap CBaseAnimating < CBaseEntity
{
	public CBaseAnimating(int entity) 
	{
		return view_as<CBaseAnimating>(entity);
	}
	
	public static native int iHandleAnimEvent();
	
#if defined _dhooks_included
	public void Hook_HandleAnimEvent(DHookCallback callback)
	{
		static Handle hHook = null;
		if (hHook == null)
		{
			hHook = DHookCreate(CBaseAnimating.iHandleAnimEvent(), HookType_Entity, ReturnType_Void, ThisPointer_CBaseEntity);
			if (hHook == null) return;
			DHookAddParam(hHook, HookParamType_ObjectPtr, -1);
		}
		DHookEntity(hHook, false, this.iEnt, _, callback);
	}
#endif
	
	public native void StudioFrameAdvance();
	public native void DispatchAnimEvents(CBaseAnimating anim);
	public native int LookupSequence(const char[] sName);
	public native float SequenceDuration(int iSequence);
	public native int SelectWeightedSequence(Activity activity);
	public native void ResetSequence(int sequence);
	public native int LookupAttachment(const char[] sAttachmentName);
    #pragma deprecated BEWARE THE USE OF THIS FUNCTION WILL CRASH YOUR SERVER!
	public native bool GetAttachment(int iAttachmentIndex, float vecOrigin[3], float vecAngles[3]);
	
	public native Address GetModelPtr();
	public native int LookupPoseParameter(const char[] sParamName);
	public native float SetPoseParameter(int iPoseParam, float flNewValue);
	public native float GetPoseParameter(int iPoseParam);
	
	#pragma deprecated Please implement this function inside your plugin
	public void PlayAnimation(const char[] sName)
	{
		int iSequence = this.LookupSequence(sName);
		if (iSequence != -1)
		{
			this.ResetSequence(iSequence);
			SetEntPropFloat(this.iEnt, Prop_Data, "m_flCycle", 0.0);
		}
	}
	#pragma deprecated Please use CBaseAnimating.LookupAttachment instead and don't add 1 to return value
	public native int FindAttachment(const char[] sAttachmentName);
};

methodmap CBaseAnimatingOverlay < CBaseAnimating
{
	public CBaseAnimatingOverlay(int entity) 
	{
		return view_as<CBaseAnimatingOverlay>(entity);
	}
	
	public native int AddGestureSequence(int iSequence, float flDuration = 1.0, bool autokill = true);
	public native int AddGesture(Activity activity, float flDuration = 1.0, bool autokill = true);
	public native bool IsPlayingGesture(Activity activity);
	public native void RestartGesture(Activity activity, bool addifmissing = true, bool autokill = true);
	public native void RemoveAllGestures();
	public native int AddLayeredSequence(int iSequence, int iPriority);
	public native void SetLayerPriority(int iLayer, int iPriority);
	public native bool IsValidLayer(int iLayer);
	public native void SetLayerDuration(int iLayer, float flDuration);
	public native float GetLayerDuration(int iLayer);
	public native void SetLayerCycle(int iLayer, float flCycle);
	public native float GetLayerCycle(int iLayer);
	public native void SetLayerPlaybackRate(int iLayer, float flPlaybackRate);
	public native void SetLayerWeight(int iLayer, float flWeight);
	public native float GetLayerWeight(int iLayer);
	public native void SetLayerBlendIn(int iLayer, float flBlendIn);
	public native void SetLayerBlendOut(int iLayer, float flBlendOut);
	public native void SetLayerAutokill(int iLayer, bool bAutokill);
	public native void SetLayerLooping(int iLayer, bool bLooping);
	public native void SetLayerNoRestore(int iLayer, bool bNoRestore);
	public native Activity GetLayerActivity(int iLayer);
	public native int GetLayerSequence(int iLayer);
	public native int FindGestureLayer(Activity activity);
	public native void RemoveLayer(int iLayer, float flKillRate = 0.2, float flKillDelay = 0.0);
	public native void FastRemoveLayer(int iLayer);
	public native CAnimationOverlay GetAnimOverlay(int iLayer);
	public native int GetNumAnimOverlays();
	public native void SetNumAnimOverlays(int iNum);
	public native bool HasActiveLayer();
	
	public int FindGestureLayerBySequence(int iSequence)
	{
		// i = layer index
		int iCount = this.GetNumAnimOverlays();
		for(int i = 0; i < iCount; i++) 
		{
			CAnimationOverlay pOverlay = this.GetAnimOverlay(i); 
			
			// Validate layer
			if (!pOverlay.IsAlive()) 
			{
				continue; 
			}

			// Validate sequence
			if (pOverlay.GetLayerSequence() == iSequence) 
			{
				return i; 
			}
		}

		// Return on the unsuccess
		return -1; 
	}

};

methodmap CBaseCombatCharacter < CBaseAnimatingOverlay
{
	public CBaseCombatCharacter(int iEntity)
	{
		return view_as<CBaseCombatCharacter>(iEntity);
	}
	public native void UpdateLastKnownArea();
	public native CNavArea GetLastKnownArea();
};

enum EventResultPriorityType
{
	RESULT_NONE = 0,
	RESULT_TRY,
	RESULT_IMPORTANT,
	RESULT_CRITICAL
}

/**
 * A single unit of logic of the NextBot behavior system. An Action can do work
 * and change to/suspend for other Actions. Actions can also contain a single
 * child Action, which runs concurrently with the parent Action.
 *
 * Actions are instantiated using a NextBotActionFactory.
 *
 * See: "The AI Systems of Left 4 Dead" by Mike Booth, "Behaviors and decision making"
 * https://steamcdn-a.akamaihd.net/apps/valve/2009/ai_systems_of_l4d_mike_booth.pdf
 *
 */
methodmap NextBotAction < INextBotEventResponder
{
	/**
	 * The entity index of the CBaseNPC utilizing this Action.
	 *
	 * Note: This is not set until before the OnStart() callback is invoked.
	 * 
	 * @return     Entity index
	 */
	property int Actor
	{
		public native get();
	}

	/**
	 * The parent of this Action.
	 *
	 * @return     The parent Action
	 */
	property NextBotAction Parent
	{
		public native get();
	}

	/**
	 * The active child of this Action.
	 *
	 * @return     The active child Action
	 */
	property NextBotAction ActiveChild
	{
		public native get();
	}

	/**
	 * The identifying name of the Action.
	 *
	 * @param sBuffer        Buffer
	 * @param iBufferLen     Buffer size
	 */
	public native void GetName(char[] sBuffer, int iBufferLen);

	/**
	 * The full name of the Action. This displays the hierarchy of Actions
	 * from the root parent Action to this Action.
	 *
	 * @param sBuffer        Buffer
	 * @param iBufferLen     Buffer size
	 */
	public native void GetFullName(char[] sBuffer, int iBufferLen);

	/**
	 * Retrieves an integer from the Action's custom data. Size of the given
	 * value is auto-detected.
	 * 
	 * This is synonymous with GetEntProp().
	 *
	 * @param sPropName     Property name
	 * @param element       Element # (starting from 0) if property is an array.
	 * @return              Value at the given property offset.
	 * @error               Invalid property or offset out of reasonable bounds.
	 */
	public native any GetData(const char[] sPropName, int element=0);

	/**
	 * Sets an integer in the Action's custom data. Size of the given value is
	 * auto-detected.
	 * 
	 * This is synonymous with SetEntProp().
	 *
	 * @param sPropName     Property name
	 * @param value         Value to set
	 * @param element       Element # (starting from 0) if property is an array.
	 * @error               Invalid property or offset out of reasonable bounds.
	 */
	public native void SetData(const char[] sPropName, any value, int element=0);

	/**
	 * Retrieves a float value from the Action's custom data.
	 * 
	 * This is synonymous with GetEntPropFloat().
	 *
	 * @param sPropName     Property name
	 * @param element       Element # (starting from 0) if property is an array.
	 * @return              Value at the given property offset.
	 * @error               Invalid property or offset out of reasonable bounds.
	 */
	public native float GetDataFloat(const char[] sPropName, int element=0);

	/**
	 * Sets a float value in the Action's custom data.
	 * 
	 * This is synonymous with SetEntPropFloat().
	 *
	 * @param sPropName     Property name
	 * @param value         Value to set
	 * @param element       Element # (starting from 0) if property is an array.
	 * @error               Invalid property or offset out of reasonable bounds.
	 */
	public native void SetDataFloat(const char[] sPropName, float value, int element=0);

	/**
	 * Retrieves a Vector value from the Action's custom data.
	 * 
	 * This is synonymous with GetEntPropVector().
	 *
	 * @param sPropName     Property name
	 * @param buffer        Vector buffer to store data in.
	 * @param element       Element # (starting from 0) if property is an array.
	 * @error               Invalid property or offset out of reasonable bounds.
	 */
	public native void GetDataVector(const char[] sPropName, float buffer[3], int element=0);

	/**
	 * Sets a Vector in the Action's custom data.
	 * 
	 * This is synonymous with SetEntPropVector().
	 *
	 * @param sPropName     Property name
	 * @param value         Value to set
	 * @param element       Element # (starting from 0) if property is an array.
	 * @error               Invalid property or offset out of reasonable bounds.
	 */
	public native void SetDataVector(const char[] sPropName, const float value[3], int element=0);

	/**
	 * Retrieves a string from the Action's custom data.
	 * 
	 * This is synonymous with GetEntPropString().
	 *
	 * @param sPropName     Property name
	 * @param sBuffer       Buffer to store value
	 * @param iBufferLen    Size of buffer
	 * @param element       Element # (starting from 0) if property is an array.
	 * @error               Invalid property or offset out of reasonable bounds.
	 */
	public native int GetDataString(const char[] sPropName, char[] sBuffer, int iBufferLen, int element=0);

	/**
	 * Sets a string in the Action's custom data.
	 * 
	 * This is synonymous with SetEntPropString().
	 *
	 * @param sPropName     Property name
	 * @param sValue        Value to set
	 * @param element       Element # (starting from 0) if property is an array.
	 * @error               Invalid property or offset out of reasonable bounds.
	 */
	public native int SetDataString(const char[] sPropName, const char[] sValue, int element=0);

	/**
	 * Whether or not the Action is suspended.
	 */
	property bool IsSuspended
	{
		public native get();
	}

	/**
	 * Action should keep running.
	 * 
	 * Note: Do not use this in event callbacks. Use TryContinue() instead.
	 */
	public native int Continue();

	/**
	 * Action should change to another Action.
	 *
	 * Notes: 
	 * 1. This is not allowed within an OnSuspend callback.
	 * 2. Do not use this in event callbacks. Use TryChangeTo() instead.
	 *
	 * @param action        Action to change to
	 * @param reason        Reason for changing to the new action.
	 * @error Action is NULL_ACTION
	 */
	public native int ChangeTo( NextBotAction action, const char[] reason=NULL_STRING );

	/**
	 * Action should suspend itself for an interrupting Action.
	 *
	 * About suspending: Suspending an Action will "bury" the Action underneath
	 * the interrupting Action, forming a stack. The buried Action will no
	 * longer update, but can still react to events.
	 *
	 * If a buried Action returns TrySuspendFor() as a response to an event,
	 * the new interrupting Action will be placed on the very top of the stack.
	 *
	 * If a buried Action returns TryChangeTo() or TryDone() as a response 
	 * to an event, every Action above the buried Action will be considered
	 * "out of scope" and will exit on the next update.
	 *
	 * Notes:
	 * 1. This is not allowed within an OnSuspend() callback.
	 * 2. Do not use this in event callbacks. Use TrySuspendFor() instead.
	 * 3. This is not to be confused with child Actions. Child Actions continue
	 * to update along with its parent, while buried Actions do not update
	 * until all Actions on top of the buried Action exit.
	 *
	 * @param interruptingAction        Interrupting Action to suspend for
	 * @param reason                    Reason for suspending for the interrupting Action.
	 * @error Action is NULL_ACTION
	 */
	public native int SuspendFor( NextBotAction interruptingAction, const char[] reason=NULL_STRING );

	/**
	 * Action should exit.
	 * 
	 * Note: Do not use this in event callbacks. Use TryDone() instead.
	 *
	 * @param reason        Reason for exiting
	 */
	public native int Done( const char[] reason=NULL_STRING );

	/**
	 * Request that the Action should keep running.
	 * 
	 * Note: This is used within event callbacks only.
	 * 
	 * @param priority      How important this response is
	 */
	public native int TryContinue( EventResultPriorityType priority = RESULT_TRY );

	/**
	 * Request that the Action should change to another Action.
	 *
	 * Note: This is used within event callbacks only.
	 *
	 * @param action        The new Action to change to.
	 * @param priority      How important this response is
	 * @param reason        The reason for changing to the new Action.
	 */
	public native int TryChangeTo( NextBotAction action, EventResultPriorityType priority = RESULT_TRY, const char[] reason=NULL_STRING );

	/**
	 * Request that the Action should suspend itself for another Action.
	 *
	 * Note: This is used within event callbacks only.
	 *
	 * @param interruptingAction        The interrupting Action to suspend for.
	 * @param priority                  How important this response is
	 * @param reason                    The reason for suspending for the interrupting Action.
	 */
	public native int TrySuspendFor( NextBotAction interruptingAction, EventResultPriorityType priority = RESULT_TRY, const char[] reason=NULL_STRING );

	/**
	 * Request that the Action should exit.
	 *
	 * Note: This is used within event callbacks only.
	 *
	 * @param priority      How important this response is
	 * @param reason        The reason for exiting
	 */
	public native int TryDone( EventResultPriorityType priority = RESULT_TRY, const char[] reason=NULL_STRING );

	/**
	 * Request that the Action should keep running. This is the same as
	 * TryContinue() except with an added reason parameter.
	 *
	 * Note: This is used within event callbacks only.
	 *
	 * @param priority      How important this response is
	 * @param reason        The reason for continuing
	 */
	public native int TryToSustain( EventResultPriorityType priority = RESULT_TRY, const char[] reason=NULL_STRING );
}

enum EventResponderType
{
	EventResponderType_OnLeaveGround = 0,
	EventResponderType_OnLandOnGround,
	EventResponderType_OnContact,
	EventResponderType_OnMoveToSuccess,
	EventResponderType_OnMoveToFailure,
	EventResponderType_OnStuck,
	EventResponderType_OnUnStuck,
	EventResponderType_OnPostureChanged,
	EventResponderType_OnAnimationActivityComplete,
	EventResponderType_OnAnimationActivityInterrupted,
	EventResponderType_OnAnimationEvent,
	EventResponderType_OnIgnite,
	EventResponderType_OnInjured,
	EventResponderType_OnKilled,
	EventResponderType_OnOtherKilled,
	EventResponderType_OnSight,
	EventResponderType_OnLostSight,
	EventResponderType_OnSound,	// Not the same as EmitSound(); in fact, it doesn't seem to be used at all!
	EventResponderType_OnSpokeConcept,
	EventResponderType_OnWeaponFired,
	EventResponderType_OnNavAreaChanged,
	EventResponderType_OnModelChanged,
	EventResponderType_OnPickUp,
	EventResponderType_OnDrop,
	EventResponderType_OnActorEmoted,

	EventResponderType_OnCommandAttack,
	EventResponderType_OnCommandApproach,
	EventResponderType_OnCommandApproachEntity,
	EventResponderType_OnCommandRetreat,
	EventResponderType_OnCommandPause,
	EventResponderType_OnCommandResume,
	EventResponderType_OnCommandString,

	EventResponderType_OnShoved,
	EventResponderType_OnBlinded,
	EventResponderType_OnTerritoryContested,
	EventResponderType_OnTerritoryCaptured,
	EventResponderType_OnTerritoryLost,
	EventResponderType_OnWin,
	EventResponderType_OnLose,

	EventResponderType_Max
}

typeset ActionEventResponderCallback
{
	// OnLeaveGround
	// OnLandOnGround
	// OnSight
	// OnLostSight
	// OnDrop (item = ground)
	// OnCommandApproachEntity (goal = ground)
	function int ( NextBotAction action, int actor, int ground );
	
	// OnContact
	// result is a CGameTrace structure
	function int ( NextBotAction action, int actor, int other, Address result );

	// OnMoveToSuccess
	function int ( NextBotAction action, int actor, Path path );

	// OnMoveToFailure
	function int ( NextBotAction action, int actor, Path path, MoveToFailureType reason );

	// OnStuck
	// OnUnStuck
	// OnPostureChanged
	// OnIgnite
	// OnModelChanged
	// OnCommandResume
	// OnWin
	// OnLose
	function int ( NextBotAction action, int actor );

	// OnAnimationActivityComplete
	// OnAnimationActivityInterrupted
	// OnCommandAttack (victim = activity)
	// OnShoved (pusher = activity)
	// OnBlinded (blinder = activity)
	// OnTerritoryContested (territoryID = activity)
	// OnTerritoryCaptured (territoryID = activity)
	// OnTerritoryLost (territoryID = activity)
	function int ( NextBotAction action, int actor, int activity );

	// OnAnimationEvent
	function int ( NextBotAction action, int actor, int event );
	function int ( NextBotAction action, int actor, int event, const char[] options );
	function int ( NextBotAction action, int actor, int event, const char[] options, float cycle, float eventtime );
	function int ( NextBotAction action, int actor, int event, const char[] options, float cycle, float eventtime, int eventtype );
	function int ( NextBotAction action, int actor, int event, const char[] options, float cycle, float eventtime, int eventSourceEntity );

	// OnInjured
	// OnKilled
	function int ( NextBotAction action, int actor, int attacker, int inflictor, float damage, int damagetype );
	function int ( NextBotAction action, int actor, int attacker, int inflictor, float damage, int damagetype, int weapon, const float damageForce[3], const float damagePosition[3] );
	function int ( NextBotAction action, int actor, int attacker, int inflictor, float damage, int damagetype, int weapon, const float damageForce[3], const float damagePosition[3], int damagecustom );

	// OnOtherKilled
	function int ( NextBotAction action, int actor, int victim, int attacker, int inflictor, float damage, int damagetype );
	function int ( NextBotAction action, int actor, int victim, int attacker, int inflictor, float damage, int damagetype, int weapon, const float damageForce[3], const float damagePosition[3] );
	function int ( NextBotAction action, int actor, int victim, int attacker, int inflictor, float damage, int damagetype, int weapon, const float damageForce[3], const float damagePosition[3], int damagecustom );

	// OnSound
	function int ( NextBotAction action, int actor, int sourceEntity, const float pos[3], KeyValues keys );

	// OnSpokeConcept
	// response is AI_Response*
	function int ( NextBotAction action, int actor, int who, const char[] concept, Address response );

	// OnWeaponFired
	// OnPickUp (item = whoFired, giver = weapon)
	// OnActorEmoted (emoter = whoFired, emote = weapon)
	function int ( NextBotAction action, int actor, int whoFired, int weapon );

	// OnNavAreaChanged
	function int ( NextBotAction action, int actor, CNavArea newArea, CNavArea oldArea );

	// OnCommandApproach
	function int ( NextBotAction action, int actor, const float pos[3], float range );

	// OnCommandRetreat
	function int ( NextBotAction action, int actor, int threat, float range );

	// OnCommandPause
	function int ( NextBotAction action, int actor, float duration );

	// OnCommandString
	function int ( NextBotAction action, int actor, const char[] command );
}

enum QueryResultType
{
	ANSWER_NO,
	ANSWER_YES,
	ANSWER_UNDEFINED
}

enum ContextualQueryType
{
	ContextualQueryType_ShouldPickup = 0,
	ContextualQueryType_ShouldHurry,
	ContextualQueryType_ShouldRetreat,
	ContextualQueryType_ShouldAttack,
	ContextualQueryType_IsHindrance,
	ContextualQueryType_SelectTargetPoint,
	ContextualQueryType_IsPositionAllowed,
	ContextualQueryType_SelectMoreDangerousThreat,
	ContextualQueryType_Max
}

typeset ActionContextualQueryCallback
{
	// ShouldPickup
	// IsHindrance
	function QueryResultType (NextBotAction action, INextBot bot, int item);

	// ShouldHurry
	// ShouldRetreat
	function QueryResultType (NextBotAction action, INextBot bot);

	// ShouldAttack
	function QueryResultType (NextBotAction action, INextBot bot, CKnownEntity knownEntity);

	// SelectTargetPoint
	// Leave pos unmodified for no response
	function void (NextBotAction action, INextBot bot, int subject, float pos[3]);

	// IsPositionAllowed
	function QueryResultType (NextBotAction action, INextBot bot, const float pos[3]);

	// SelectMoreDangerousThreat
	// Return NULL_KNOWN_ENTITY for no response
	function CKnownEntity (NextBotAction action, INextBot bot, int botEntity, CKnownEntity threat1, CKnownEntity threat2); 
}

enum NextBotActionCallbackType
{
	NextBotActionCallbackType_OnStart = 0,                  // Action started
	NextBotActionCallbackType_Update,                       // Action does work
	NextBotActionCallbackType_OnSuspend,                    // Action is suspended for another Action. Only Continue() and Done() are allowed.
	NextBotActionCallbackType_OnResume,                     // Action resumes after suspension
	NextBotActionCallbackType_OnEnd,                        // Action exits
	NextBotActionCallbackType_InitialContainedAction,       // Creation of a child Action
	NextBotActionCallbackType_CreateInitialAction,          // Action was created as the initial Action of the Behavior
	NextBotActionCallbackType_IsAbleToBlockMovementOf,      // Returning false will skip collision resolution with the other bot; default is true.
	NextBotActionCallbackType_Max
}

typeset NextBotActionCallback
{
	// OnStart
	// OnSuspend (interruptingAction = priorAction)
	// OnResume (interruptingAction = priorAction)
	function int ( NextBotAction action, int actor, NextBotAction priorAction );

	// Update
	function int ( NextBotAction action, int actor, float interval );

	// OnEnd
	function void ( NextBotAction action, int actor, NextBotAction nextAction );

	// InitialContainedAction
	function NextBotAction ( NextBotAction action, int actor );

	// CreateInitialAction
	function void ( NextBotAction action );

	// IsAbleToBlockMovementOf
	function bool ( NextBotAction action, INextBot bot );
}

methodmap NextBotActionFactory < Handle
{
	/**
	 * A class that declares the data structure and callbacks of a particular
	 * Action and instantiates Actions.
	 *
	 * @param sName     Name of the Action, which can be retrieved using GetName().
	 * @return          Handle to NextBotActionFactory object.
	 */
	public native NextBotActionFactory(const char[] sName);

	/**
	 * Defines a callback for the Action.
	 *
	 * @param callbackType     Type of callback
	 * @param callback
	 */
	public native void SetCallback(NextBotActionCallbackType callbackType, NextBotActionCallback callback);

	/**
	 * Defines a contextual query callback for the Action.
	 *
	 * @param callbackType     Type of callback
	 * @param callback
	 */
	public native void SetQueryCallback(ContextualQueryType callbackType, ActionContextualQueryCallback callback);

	/**
	 * Defines an event callback for the Action.
	 *
	 * @param callbackType     Type of callback
	 * @param callback
	 */
	public native void SetEventCallback(EventResponderType callbackType, ActionEventResponderCallback callback);

	/**
	 * Begins defining properties stored on the Action.
	 *
	 * @return     The NextBotActionFactory to chain calls
	*/
	public native NextBotActionFactory BeginDataMapDesc();

	/**
	 * Defines an integer property on the Action.
	 *
	 * @param sFieldName     Property name
	 * @param iNumElements   Number of elements. If > 1, will declare the field
	 *                       as an array.
	 * @return               The NextBotActionFactory to chain calls
	 */
	public native NextBotActionFactory DefineIntField(const char[] sFieldName, int iNumElements=1);

	/**
	 * Defines a float property on the Action.
	 *
	 * @param sFieldName     Property name
	 * @param iNumElements   Number of elements. If > 1, will declare the field
	 *                       as an array.
	 * @return               The NextBotActionFactory to chain calls
	 */
	public native NextBotActionFactory DefineFloatField(const char[] sFieldName, int iNumElements=1);

	/**
	 * Defines a character property on the Action.
	 *
	 * @param sFieldName     Property name
	 * @param iNumElements   Number of elements. If > 1, will declare the field
	 *                       as an array.
	 * @return               The NextBotActionFactory to chain calls
	 */
	public native NextBotActionFactory DefineCharField(const char[] sFieldName, int iNumElements=1);

	/**
	 * Defines a boolean property on the Action.
	 *
	 * @param sFieldName     Property name
	 * @param iNumElements   Number of elements. If > 1, will declare the field
	 *                       as an array.
	 * @return               The NextBotActionFactory to chain calls
	 */
	public native NextBotActionFactory DefineBoolField(const char[] sFieldName, int iNumElements=1);

	/**
	 * Defines a Vector property on the Action.
	 *
	 * @param sFieldName     Property name
	 * @param iNumElements   Number of elements. If > 1, will declare the field
	 *                       as an array.
	 * @return               The NextBotActionFactory to chain calls
	 */
	public native NextBotActionFactory DefineVectorField(const char[] sFieldName, int iNumElements=1);

	/**
	 * Defines a string property on the Action.
	 *
	 * @param sFieldName     Property name
	 * @param iNumElements   Number of elements. If > 1, will declare the field
	 *                       as an array.
	 * @return               The NextBotActionFactory to chain calls
	 */
	public native NextBotActionFactory DefineStringField(const char[] sFieldName, int iNumElements=1);

	/**
	 * Finishes the datamap definition.
	 */
	public native void EndDataMapDesc();

	/**
	 * Creates an Action.
	 *
	 * @return     The new Action
	*/
	public native NextBotAction Create();
}

typeset CEntityFactoryPostConstructor
{
	function void (int entity);
}

typeset CEntityFactoryOnRemoveCallback
{
	function void (int entity);
}

typeset InputFuncCallback
{
	// Void
	function void (int entity, int activator, int caller);

	// Integer
	function void (int entity, int activator, int caller, int value);

	// Float
	function void (int entity, int activator, int caller, float value);

	// Color32
	function void (int entity, int activator, int caller, const int value[4]);

	// Vector
	function void (int entity, int activator, int caller, const float value[3]);

	// String
	function void (int entity, int activator, int caller, const char[] value);

	// Integer/Float/Unknown
	function void (int entity, int activator, int caller, any value);
}

enum InputFuncValueType
{
	InputFuncValueType_Void = 0,
	InputFuncValueType_String,
	InputFuncValueType_Boolean,
	InputFuncValueType_Color32,
	InputFuncValueType_Float,
	InputFuncValueType_Integer,
	InputFuncValueType_Vector,
	InputFuncValueType_Max
}

methodmap CEntityFactory < Handle
{
	/**
	 * A class that facilites the creation of entities of a specified class.
	 * Factories created this way must derive from an existing installed factory
	 * via the `DeriveFrom*()` functions.
	 *
	 * Once a CEntityFactory is installed via Install(), the game will utilize
	 * the factory to create entities under its classname, and can also be
	 * utilized by maps.
	 *
	 * @param classname         The entity's classname. This cannot match the
	 *                          classname of an already installed factory.
	 * @param postConstructor   Called when the factory finishes creating the entity.
	 *                          This is the best place to initialize your entity.
	 * @param onRemove          Called when an entity created by this factory is removed.
	 *                          Perform any needed cleanup for your entity here.
	 * @param error             Classname is NULL or empty, or out of memory.
	 */
	public native CEntityFactory(const char[] classname, CEntityFactoryPostConstructor postConstructor=INVALID_FUNCTION, CEntityFactoryOnRemoveCallback onRemove=INVALID_FUNCTION);
	
	/**
	 * Instructs the factory to use CBaseNPC (NextBot) as the base class.
	 */
	public native void DeriveFromNPC();

	public native void SetInitialActionFactory( NextBotActionFactory factory );

	/**
	 * Instructs the factory to use CBaseEntity as the base class.
	 *
	 * @param bServerOnly       If true, entity will be server side only and not
	 *                          networked to clients.
	 */
	public native void DeriveFromBaseEntity(bool bServerOnly=false);

	/**
	 * Instructs the factory to use an existing installed factory as the base factory.
	 *
	 * You can specify a base factory that was created via CEntityFactory(), even
	 * if the base factory was created by another plugin. However, if the base 
	 * factory is uninstalled, this factory will be uninstalled first.
	 *
	 * @param classname     The classname of the installed factory.
	 */
	public native void DeriveFromClass(const char[] classname);

	/**
	 * Instructs the factory to use the specified factory as a base.
	 *
	 * @param baseFactory     The base factory
	 */
	public native void DeriveFromFactory(CEntityFactory baseFactory);

	/**
	 * Installs the factory. This marks the factory available for use.
	 * For non-abstract factories, the factory will be added to the global
	 * entity factory dictionary.
	 *
	 * @error	An installed factory already has classname, or base factory/class
	 *          doesn't exist.
	 */
	public native void Install();

	/**
	 * Uninstalls the factory. If any CEntityFactory's are using this factory
	 * as a base, then those factories will be uninstalled first.
	 *
	 * Upon uninstalling a factory, all entities that were directly created
	 * by this factory (not including derived factories) will be removed.
	 */
	public native void Uninstall();

	/**
	 * Tells if the factory is installed or not.
	 *
	 * @return     Installed
	 */
	property bool IsInstalled
	{
		public native get();
	}

	/**
	 * Tells if the factory is abstract or not.
	 * 
	 * An abstract factory is never added to the entity factory dictionary,
	 * and is used only as a base for other factories. This is synonymous with
	 * abstract classes in C++.
	 *
	 * You are still required to install abstract factories in order for them
	 * to be used by other factories.
	 *
	 * To use an abstract factory as a base, you need to use DeriveFromFactory().
	 */
	property bool IsAbstract
	{
		public native get();
		public native set(bool bIsAbstract);
	}

	/**
	 * The entity classname the factory was created with.
	 *
	 * @param sBuffer        Buffer
	 * @param iBufferLen     Size of buffer
	 */
	public native void GetClassname(char[] sBuffer, int iBufferLen);

	/**
	 * The CEntityFactory that created the entity.
	 *
	 * @param entity     Entity index/reference
	 * @return           CEntityFactory, or null if not created by a CEntityFactory.
	 */
	public static native CEntityFactory GetFactoryOfEntity(int entity);

	/**
	 * Number of installed CEntityFactory's.
	 *
	 * @return     Number of installed CEntityFactory's
	 */
	public static native int GetNumInstalledFactories();

	/**
	 * Gets list of installed CEntityFactory's.
	 *
	 * @param array         Buffer
	 * @param arraySize     Buffer size
	 * @return              Number of installed CEntityFactory's
	 */
	public static native int GetInstalledFactories(CEntityFactory[] array, int arraySize);

	// Datamap

	/**
	 * Begin defining the datamap structure. The factory uses this datamap to
	 * create and map out custom, user-defined properties on the entity. These 
	 * properties can be accessed using Get/SetEntProp. Use EndDataMapDesc()
	 * to finish defining the datamap.
	 *
	 * If deriving from another CEntityFactory (whether by factory or classname), 
	 * you must specify and install the base factory before calling 
	 * BeginDataMapDesc() on this factory, as offsets are calculated based on 
	 * the entity size of the base factory. You also must not change the base
	 * factory's datamap during/after defining this factory's datamap, as this
	 * will lead to undefined behavior.
	 *
	 * About key fields: If sKeyName is given, this will declare the property
	 * as a key field, which can be accessed by the map and the DispatchKeyValue
	 * function using sKeyName. Key fields cannot be declared as an array,
	 * meaning iNumElements must be set to 1.
	 *
	 * @param sDataClass      Name of the datamap. If null or empty, will use
	 *                        entity's classname.
	 * @return                The CEntityFactory to chain calls
	 * @error                 Beginning datamap definition before base factory 
	 *                        is installed
	 */
	public native CEntityFactory BeginDataMapDesc(const char[] sDataClass=NULL_STRING);

	/**
	 * Defines an integer field in the datamap.
	 *
	 * @param sFieldName      Name of the field
	 * @param iNumElements    Number of elements. If > 1, will declare the field
	 *                        as an array.
	 * @param sKeyName        Key field name. See BeginDataMapDesc's documentation
	 * @return                The CEntityFactory to chain calls
	 */
	public native CEntityFactory DefineIntField(const char[] sFieldName, int iNumElements=1, const char[] sKeyName=NULL_STRING);

	/**
	 * Defines a float field in the datamap.
	 *
	 * @param sFieldName      Name of the field
	 * @param iNumElements    Number of elements. If > 1, will declare the field
	 *                        as an array.
	 * @param sKeyName        Key field name. See BeginDataMapDesc's documentation
	 * @return                The CEntityFactory to chain calls
	 */
	public native CEntityFactory DefineFloatField(const char[] sFieldName, int iNumElements=1, const char[] sKeyName=NULL_STRING);

	/**
	 * Defines a character field in the datamap.
	 *
	 * @param sFieldName      Name of the field
	 * @param iNumElements    Number of elements. If > 1, will declare the field
	 *                        as an array.
	 * @param sKeyName        Key field name. See BeginDataMapDesc's documentation
	 * @return                The CEntityFactory to chain calls
	 */
	public native CEntityFactory DefineCharField(const char[] sFieldName, int iNumElements=1, const char[] sKeyName=NULL_STRING);

	/**
	 * Defines a boolean field in the datamap.
	 *
	 * @param sFieldName      Name of the field
	 * @param iNumElements    Number of elements. If > 1, will declare the field
	 *                        as an array.
	 * @param sKeyName        Key field name. See BeginDataMapDesc's documentation
	 * @return                The CEntityFactory to chain calls
	 */
	public native CEntityFactory DefineBoolField(const char[] sFieldName, int iNumElements=1, const char[] sKeyName=NULL_STRING);

	/**
	 * Defines a Vector field in the datamap.
	 *
	 * @param sFieldName      Name of the field
	 * @param iNumElements    Number of elements. If > 1, will declare the field
	 *                        as an array.
	 * @param sKeyName        Key field name. See BeginDataMapDesc's documentation
	 * @return                The CEntityFactory to chain calls
	 */
	public native CEntityFactory DefineVectorField(const char[] sFieldName, int iNumElements=1, const char[] sKeyName=NULL_STRING);

	/**
	 * Defines a string field in the datamap.
	 *
	 * @param sFieldName      Name of the field
	 * @param iNumElements    Number of elements. If > 1, will declare the field
	 *                        as an array.
	 * @param sKeyName        Key field name. See BeginDataMapDesc's documentation
	 * @return                The CEntityFactory to chain calls
	 */
	public native CEntityFactory DefineStringField(const char[] sFieldName, int iNumElements=1, const char[] sKeyName=NULL_STRING);

	/**
	 * Defines an entity field in the datamap.
	 *
	 * @param sFieldName      Name of the field
	 * @param iNumElements    Number of elements. If > 1, will declare the field
	 *                        as an array.
	 * @return                The CEntityFactory to chain calls
	 */
	public native CEntityFactory DefineEntityField(const char[] sFieldName, int iNumElements=1);

	/**
	 * Defines an input function. Inputs can be invoked using AcceptEntityInput,
	 * ent_fire, or from outputs.
	 *
	 * @param sInputName      Name of the input
	 * @param valueType       Type of value that the input function callback
	 *                        should handle.
	 * @param handler         Callback to handle the input.
	 * @return                The CEntityFactory to chain calls
	 */
	public native CEntityFactory DefineInputFunc(const char[] sInputName, InputFuncValueType valueType, InputFuncCallback handler);

	/**
	 * Defines an output. Outputs can be fired using FireEntityOutput.
	 *
	 * @param sOutputName     Name of the output
	 * @return                The CEntityFactory to chain calls
	 */
	public native CEntityFactory DefineOutput(const char[] sOutputName);

	/**
	 * Finishes the datamap definition.
	 */
	public native void EndDataMapDesc();
}

/**
 * Called after CEntityFactory was installed.
 *
 * @param classname     The classname of the factory
 * @param factory       Factory that was installed
 */
forward void CEntityFactory_OnInstalled(const char[] classname, CEntityFactory factory);

/**
 * Called after CEntityFactory was uninstalled.
 *
 * @param classname     The classname of the factory
 * @param factory       Factory that was uninstalled
 */
forward void CEntityFactory_OnUninstalled(const char[] classname, CEntityFactory factory);

#if !defined _navmesh_included
public float Path_Cost(INextBot bot, CNavArea area, CNavArea fromArea, CNavLadder ladder, int iElevator, float length)
{
	static int iTime = 0;
	if (iTime < GetTime())
	{
		iTime = GetTime();
	}
	
	float dist;
	if ( ladder != NULL_LADDER_AREA )
	{
		dist = ladder.length;
	}
	else if ( length > 0.0 )
	{
		dist = length;
	}
	else
	{
		float vecAreaCenter[3], vecFromAreaCenter[3];
		area.GetCenter(vecAreaCenter);
		fromArea.GetCenter(vecFromAreaCenter);
		dist = GetVectorDistance(vecAreaCenter, vecFromAreaCenter);
	}

	float cost = dist + fromArea.GetCostSoFar();
	
	// if this is a "crouch" area, add penalty
	int attributes = area.GetAttributes();
	if ( (attributes & NAV_MESH_CROUCH) )
	{
		const float crouchPenalty = 20.0;
		cost += crouchPenalty * dist;
	}

	// if this is a "jump" area, add penalty
	if ( (attributes & NAV_MESH_JUMP) )
	{
		const float jumpPenalty = 5.0;
		cost += jumpPenalty * dist;
	}
	return cost;
}
#endif

public bool Path_FilterIgnoreActors(int entity, int contentsMask, int desiredcollisiongroup)
{
	if ((0 < entity <= MaxClients) || (view_as<Address>(CBaseNPC_GetNextBotOfEntity(entity)) != Address_Null))
	{
		return false;
	}
	return true;
}

public bool Path_FilterOnlyActors(int entity, int contentsMask, int desiredcollisiongroup)
{
	return ((0 < entity <= MaxClients) || TheNPCs.FindNPCByEntIndex(entity) == INVALID_NPC);
}

forward Action CBaseEntity_SetLocalAngles(int iEntity, float vecNewAngles[3]);
forward Action CBaseCombatCharacter_EventKilled(int iEntity, int &iAttacker, int &iInflictor, float &flDamage, int &iDamagetype, int &iWeapon, float vecDamageForce[3], float vecDamagePosition[3], int iDamagecustom);

public Extension __ext_cbasenpc = 
{
	name = "cbasenpc",
	file = "cbasenpc.ext",
	autoload = 1,
#if defined REQUIRE_EXTENSIONS
	required = 1,
#else
	required = 0,
#endif
};

#endif
